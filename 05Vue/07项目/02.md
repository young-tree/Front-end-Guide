### 1.判断滚动到底部

```js
const reachBottom = () => {
  // 滚动了多少(只要你在滚它就会发生变化)
  const scrollTop = document.documentElement.scrollTop;

  // 总共可以滚动的距离(固定值, 内容不增加就永远是固定值, 内容增加才会变大)
  const scrollHeight = document.documentElement.scrollHeight;

  // 客户端的高度(可视高度, 设备不变就永远是固定值)
  const clientHeight = document.documentElement.clientHeight;

  // 到达底部后调用action函数
  if (scrollHeight - 1 <= clientHeight + scrollTop) homeStore.getHouseListAction()
}

onMounted(() => {
  window.addEventListener("scroll", reachBottom)
})
onUnmounted(() => {
  window.removeEventListener("scroll", reachBottom)
})
```

### 2.缓存路由页面

```html
<router-view v-slot="{ Component }">
  <keep-alive includs="home">
    <component :is="Component" />
  </keep-alive>
</router-view>
```

### 3.跳转到指定位置

```js
const isShow = ref(false)

const reachBottom = () => {
  const scrollTop = document.documentElement.scrollTop;

  if (scrollTop > 400) {
    isShow.value = true
  } else {
    isShow.value = false
  }
}

onMounted(() => {
  window.addEventListener("scroll", reachBottom)
})
onUnmounted(() => {
  window.removeEventListener("scroll", reachBottom)
})

const arr = ref([])
const detailRef = ref()
const getEl = (value: any) => {
  if(!value) return
  const aaa = value.$el.offsetTop as never
  arr.value.push(aaa)
}

let ccc: any
onMounted(() => {
  watch(arr.value, () => {
    const abc = toRaw(arr.value)
    ccc = abc.slice(-6)
  })
})

const arr1 = ref(["设施", "房东", "评论", "须知", "周边", "价格"])
const abc = (index: number) => {
  window.scrollTo({
    top: ccc[index] - 50,
    behavior: "smooth"
  })
}
window.scrollTo({top: 0})

const index = ref(0)
const infoScroll = () => {
  const scrollTop = document.documentElement.scrollTop;
  for(let i = 0; i < 6; i++) {
    if (ccc[i] > scrollTop + 50) {
      index.value = i - 1
      break
    }
  }
}

onMounted(() => {
  window.addEventListener("scroll", infoScroll)
})
onUnmounted(() => {
  window.removeEventListener("scroll", infoScroll)
})
```

### 4.详情页tabbar

```js
import { ref, watch } from "vue"

const props = defineProps({
  arr1: {
    type: Array
  },
  arr: {
    type: Array
  },
  index: {
    type: Number
  }
})
const emit = defineEmits(["returnIndex"])
const currentIndex: any = ref(0)
let isClic = false
let currentIndex1 = -1
const itemClick = (index: number) => {
  isClic = true
  currentIndex.value = index
  currentIndex1 = index
  emit("returnIndex", index)
}

watch(() => props.index, () => {
  if (currentIndex1 === props.index) {
    isClic = false
  }
  if(isClic) return
  currentIndex.value = props.index
})
```

### 5.小总结

- 每做一个小模块都应该精细的计算距离
  - 下次注意
- 如果使用vw单位，各端各浏览器尺寸适配应该会好一些
  - 用vw的插件解决
- 性能问题，页面跳转回来还得重新请求数据浪费性能，应该使用一些缓存方案（待思考）
  - 第2条已经解决了

### 6.移动端适配

- postcss-px-to-viewport

- 可以去vant官网有一节可以看

- 创建postcss.config.js文件

  ```js
  module.exports = {
    plugins: {
      'postcss-px-to-viewport': {
        viewportWidth: 375,
        // selectorBlackList: ["favor"]  // 黑名单
      },
    },
  };
  ```


