```js
const PROMISE_STATUS_PENDING = "pending";
const PROMISE_STATUS_FULFILLED = "fulfilled";
const PROMISE_STATUS_REJECTED = "rejected";

class YTPromise {
  constructor(executor) {
    this.status = PROMISE_STATUS_PENDING;
    this.value = undefined;
    this.reason = undefined;
    this.onfulfilledFns = [];
    this.onrejectedFns = [];
    this.resTimes = 0;
    this.errTimes = 0;

    const resolve = (value) => {
      if(this.status === PROMISE_STATUS_PENDING) {
        queueMicrotask(() => {
          if (this.status !== PROMISE_STATUS_REJECTED && this.resTimes === 0) {
            this.status = PROMISE_STATUS_FULFILLED;
            this.resTimes += 1;
            this.value = value;
            this.onfulfilledFns.forEach(item => item());
          }
        });
      };
    };
    const reject = (reason) => {
      if(this.status === PROMISE_STATUS_PENDING) {
        queueMicrotask(() => {
          if (this.status !== PROMISE_STATUS_FULFILLED && this.errTimes === 0) {
            this.status = PROMISE_STATUS_REJECTED;
            this.errTimes += 1;
            this.reason = reason;
            this.onrejectedFns.forEach(item => item());
          }
        });
      };
    };

    try {
      executor(resolve, reject);
    } catch(err) {
      reject(err);
    };
  };

  isFn(fn) {
    if(Object.prototype.toString.call(fn) === "[object Function]") return true;
  };

  thenChainCall(resolve, reject, item, result) {
    try {
      // 这里item(result)就是实例化YTPromise而来的
      // 所以item(result).__proto__ = YTPromise.prototype
      if(result instanceof YTPromise) {
        if (result.status === PROMISE_STATUS_FULFILLED) {
          const reValue = item(result.value);
          newY(reValue);
        } else if (result.status === PROMISE_STATUS_REJECTED) {
          const reValue = item(result.reason);
          newY(reValue);
        };
      } else {
        const reValue = item(result);
        newY(reValue);
      }
      function newY(reValue) {
        if(reValue instanceof YTPromise) {
          setTimeout(() => {
            if (reValue.status === PROMISE_STATUS_FULFILLED) {
              resolve(reValue.value);
            } else if (reValue.status === PROMISE_STATUS_REJECTED) {
              reject(reValue.reason);
            };
          });
        } else {
          resolve(reValue);
        };
      }
    } catch(err) {
      reject(err);
    };
  };

  then(onfulfilled, onrejected) {
    onrejected = onrejected ?? (err => { throw err });
    onfulfilled = onfulfilled ?? (value => { return value });
    return new YTPromise((resolve, reject) => {
      if (this.status === PROMISE_STATUS_FULFILLED) {
        this.isFn(onfulfilled) && 
        this.thenChainCall(resolve, reject, onfulfilled, this.value);
      } else if(this.status === PROMISE_STATUS_REJECTED) {
        this.isFn(onrejected) && 
        this.thenChainCall(resolve, reject, onrejected, this.reason);
      };
      if (this.status === PROMISE_STATUS_PENDING) {
        this.isFn(onfulfilled) && this.onfulfilledFns.push(() => {
          this.thenChainCall(resolve, reject, onfulfilled, this.value);
        });
        this.isFn(onrejected) && this.onrejectedFns.push(() => {
          this.thenChainCall(resolve, reject, onrejected, this.reason);
        });
      };
    })
  };
  catch(onrejected) {
    return this.then(undefined, onrejected);
  };
  finally(onfinally) {
    this.then(onfinally);
  };
  static resolve(value) {
    return new YTPromise(resolve => resolve(value))
  };
  static reject(reason) {
    return new YTPromise((resolve, reject) => reject(reason));
  };
  static all(promises) {
    const values = [];
    return new YTPromise((resolve, reject) => {
      promises.forEach(promise => {
        if(promise instanceof YTPromise) {
          promise.then(res => {
            values.push(res);
            if(values.length === promises.length) {
              resolve(values);
            };
          }).catch(err => {
            reject(err);
          });
        } else {
          setTimeout(() => {
            values.push(promise);
            if(values.length === promises.length) {
              resolve(values);
            };
          });
        };
      });
    });
  };
  static allSettled(promises) {
    const values = [];
    return new YTPromise((resolve, reject) => {
      promises.forEach(promise => {
        console.log(promise instanceof YTPromise)
        if(promise instanceof YTPromise) {
          promise.then(res => {
            values.push({status: "fulfilled", value: res});
            console.log(res)
            if(values.length === promises.length) {
              console.log(789)
              resolve(values);
            };
          }).catch(err => {
            values.push({status: "rejected", reason: err});
            if(values.length === promises.length) {
              console.log(456)
              reject(values);
            };
          });
        } else {
          values.push({status: "fulfilled", value: promise});
          if(values.length === promises.length) {
            console.log(123)
            resolve(values);
          };
        }
      });
    });
  };
  static race(promises) {
    return new YTPromise((resolve, reject) => {
      promises.forEach(promise => {
        promise.then(resolve, reject);
      });
    });
  };
  static any(promises) {
    const reasons = [];
    return new YTPromise((resolve, reject) => {
      promises.forEach(promise => {
        promise.then(resolve).catch(err => {
          reasons.push(err);
          if(promises.length === reasons.length) {
            reject(new AggregateError(reasons));
          }
        });
      })
    })
  }
};
```

