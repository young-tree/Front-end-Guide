### 1.类方法——resolve

```js
static resolve(value) {
  return new YTPromise(resolve => resolve(value))
};
```

### 2.类方法——reject

```js
static reject(reason) {
  return new YTPromise((resolve, reject) => reject(reason));
};
```

### 3.类方法——all

```js
static all(promises) {
  const values = [];
  return new YTPromise((resolve, reject) => {
    promises.forEach(promise => {
      if(promise instanceof YTPromise) {
        promise.then(res => {
          values.push(res);
          if(values.length === promises.length) {
            resolve(values);
          };
        }).catch(err => {
          reject(err);
        });
      } else {
        setTimeout(() => {
          values.push(promise);
          if(values.length === promises.length) {
            resolve(values);
          };
        });
      };
    });
  });
};
```

```js
const p1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(111);
  }, 1000);
});
const p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(222);
  }, 2000);
});
const p3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(333);
  }, 3000);
});

YTPromise.all([p1, p2, p3]).then(res => {
  console.log(res);
}).catch(err => {
  console.log(err);
});
```

### 4.类方法——allSettled

```js
static allSettled(promises) {
  const values = [];
  return new YTPromise((resolve, reject) => {
    promises.forEach(promise => {
      console.log(promise instanceof YTPromise)
      if(promise instanceof YTPromise) {
        promise.then(res => {
          values.push({status: "fulfilled", value: res});
          console.log(res)
          if(values.length === promises.length) {
            console.log(789)
            resolve(values);
          };
        }).catch(err => {
          values.push({status: "rejected", reason: err});
          if(values.length === promises.length) {
            console.log(456)
            resolve(values);
          };
        });
      } else {
        values.push({status: "fulfilled", value: promise});
        if(values.length === promises.length) {
          console.log(123)
          resolve(values);
        };
      }
    });
  });
};
```

- 这里是有问题的，Promise的实现是有顺序的

  ```js
  const p1 = new YTPromise((resolve, reject) => {
    setTimeout(() => {
      resolve(111);
    }, 4000);
  });
  const p2 = new YTPromise((resolve, reject) => {
    setTimeout(() => {
      resolve(222);
    }, 2000);
  });
  const p3 = new YTPromise((resolve, reject) => {
    setTimeout(() => {
      resolve(333);
    }, 3000);
  });
  
  YTPromise.all([p1, p2, p3, "aaa"]).then(res => {
    console.log(res);
  });
  ```

  - 我们的打印结果是什么？

    ```js
    [ 'aaa', 222, 333, 111 ]
    ```

  - 谁执行快谁在前面

  - Promise是谁先执行，谁就在前面

  - 我猜测执行的时候给他包裹了某种东西，可以实现有顺序的执行

### 5.类方法——race

```js
static race(promises) {
  return new YTPromise((resolve, reject) => {
    promises.forEach(promise => {
      promise.then(res => {
        resolve(res);
      }).catch(err => {
        reject(err);
      });
    });
  });
};
```

也可以这么写

```js
static race(promises) {
  return new YTPromise((resolve, reject) => {
    promises.forEach(promise => {
      promise.then(resolve, reject);
    });
  });
};
```

### 6.类方法——any

- 至少等到有一个resolve成功，就返回这个resolve值

- 如果全都是reject，就返回一个列表

  ```js
  static any(promises) {
    const reasons = [];
    return new YTPromise((resolve, reject) => {
      promises.forEach(promise => {
        promise.then(resolve).catch(err => {
          reasons.push(err);
          if(promises.length === reasons.length) {
            reject(new AggregateError(reasons));
          }
        });
      })
    })
  }
  ```

  