### 1.灵活的JavaScript

- 下面的代码执行会不会报错呢？

  ```js
  age = 18;
  message = "Hello World";
  
  console.log(age);
  console.log(message);
  
  true.foo = "abc";
  ```

  - 其实是不会报错的

- 我们说他灵活，其实不如说他懒散，没做好

  - 那么上面的代码很有可能在浏览器或者node版本迭代的过程中就不能执行了
  - 也就是说存在风险，或安全隐患

### 2.严格模式

- 在es5中，JavaScript提出了严格模式这个概念

  - 是一种具有限制性的JavaScript模式，让代码隐式的脱离了”懒散模式“
  - 支持严格模式的浏览器，在检测到代码开启了严格模式后，浏览器会以更加严格的方式对代码进行检测和执行

- 严格模式对正常JavaScript代码进行了一些限制

  - 严格模式通过抛出错误来消除一些原有的静默错误

    ```js
    age = 18;
    
    var obj = {};
    Object.defineProperty(obj, "name", {writable: false});
    obj.name = "yt";
    ```

    - 第一个age=18如果不是在严格模式下不会报错，但是在严格模式下会报错
    - 第二个已经给obj中的name属性设置了不可写入，但是依然写入了。不在严格模式下不会报错，在严格模式下会报错。
    - 像这种，在非严格模式下，代码出现错误，但不会报错的错误就称为静默错误

  - 严格模式让JS引擎在执行代码时可以进行更多地优化（不需要对一些特殊的语法进行处理）

  - 严格模式下保留字是不能用的

    ```js
    var class = 123;
    var let = "abc";
    // 在以前是可以用的
    ```

    - 禁用了在ECMAScript未来版本中可能会定义的一些语法

### 3.开启严格模式

- 支持在js文件中开启严格模式

  ```js
  "use strict";
  ```

  - 要单独为每个文件开启严格模式

- 支持在某个函数中开启严格模式（粒度化迁移）

  ```js
  function foo() {
    "use strict";
  
    true.foo = "abc"
  };
  
  foo();
  ```

### 4.严格模式下常见的一些限制

1. 意外创建全局变量

   ```js
   message = "hello";
   
   function foo() {
     abc = "abc"
   };
   ```

2. 不允许函数有相同的参数名称

   ```js
   function foo(x, y, x) {
     console.log(x);  // 40
     console.log(y);  // 20
   };
   
   foo(30, 20, 40);
   ```

   - 后面的x会覆盖前面的x

3. 静默错误

   ```js
   NaN = 123
   
   var obj = {};
   Object.defineProperty(obj, "name", {
     configurable: false,
     writable: false,
     value: "abc",
   });
   
   delete obj.name;  // 这个也是一个静默错误，因为我们已经给它设置了不可配置这个属性了
   console.log(obj);
   ```

4. 不允许使用原先的八进制格式

   ```js
   var num = 0123
   ```

   - 在早期的时候，以0开头的数字表示八进制

   ```js
   "use strict";
   
   var num = 0123;
   ```

   ![image-20220228184847703](https://s2.loli.net/2022/03/01/rZHQLGF4EzhP8l7.png)
   ```js
   var num2 = 0b1011;  // 0b表示2进制 11
   var num8 = 0o123;  // 0o表示8进制 83
   var num16 = 0x123;  // 0x表示16进制 291
   ```

5. with语句不允许使用

6. eval函数不会向上引用变量

   ```js
   eval(`var message = "Hello World!";console.log(message);`);  // Hello World!
   console.log(message);  // Hello World!
   ```

   - var message = "Hello World!";相当于是在全局写的

   ```js
   "use strict";
   eval(`var message = "Hello World!";console.log(message);`);
   console.log(message);  // 未定义
   ```

### 5.严格模式下的this

非箭头函数的自执行函数（默认指向），this指向undefined

```js
function foo() {
  console.log(this);  // window
};

foo();
```

```js
"use strict";
function foo() {
  console.log(this);  // undefined
};

foo();
```

- 这样会不会有影响呢？
  - 不会的
  - 我们用window的时候都是直接用window的

### 6.setTimeout的this

```js
"use strict";
setTimeout(function() {
  console.log(this)  // window
}, 100);
```

- 正常情况下应该指向undefined
- 但是指向window
- 所以说它应该通过显示绑定，绑定了window

```js
"use strict";
[1,2,3].forEach(function() {
  console.log(this)
});
```

- 这里就是undefined，所以很有可能是拿到函数自执行