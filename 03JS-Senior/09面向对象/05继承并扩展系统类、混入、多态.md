### 1.扩展系统提供的类

- 现在有一个Person类，如果你，没有写继承的话，它其实是继承自Object

  ```js
  class Person {};
  
  class Person extends Object {};
  ```

  - 这两段代码是一个意思
  - 在js中所有的类，最终都是继承自Object的

- 我们之前写的继承是继承自自己创建的类，比如

  ```js
  class Person {};
  
  class Student extends Person {};
  ```

- 其实我们也可以继承自系统提供的类

- 比如说我们平常，经常使用到数组这个类

  ```js
  var arr = new Array(1, 2, 3);
  ```

  - 当然你也直接可以通过字面量的方式创建一个数组
  - 但是我们现在想要使用数组中的一些方法，不过这些方法并不存在
  - 比如直接获取数组的第一个元素
  - 或者直接获取数字的最后一个元素
  - 当然你大可不必这样做，直接arr[0];或者arr[arr.length - 1];这里主要是为了举例子

- 代码可以这样写

  ```js
  class YTArry extends Array {
    firstItem() {
      return this[0];
    };
    lastItem() {
      return this[this.length - 1];
    };
  };
  
  var ytarr = new YTArry(5, 3, 4);
  console.log(ytarr.firstItem());  // 5
  console.log(ytarr.lastItem()); // 4
  var newArr = ytarr.filter(item => {
    return item % 2 === 0;
  });
  
  console.log(newArr);
  ```

  - 我们不仅继承自系统提供的类，还可以对系统提供的类进行扩展

  - 我们在这里可能会有疑问，不是必须要在constructor方法中调用一下super吗？

  - 怎么这里没有调用？依然可以运行成功呢？我们看一下下面这段代码

    ```js
    class Person {
      constructor(name, age){
        this.name = name;
        this.age = age;
      };
    };
    
    class Student extends Person {};
    
    var stu = new Student("yt", 22);
    console.log(stu); // Student {name: 'yt', age: 22}
    ```

    - 你会发现成功了
    - 那么什么时候一定要用到super呢？子类在使用constructor时必须使用super

### 2.js实现混入

- js没有明确的关于混入的方法

- 我们只能通过js的一些技巧去实现混入的效果

- js仅支持单继承，即每个类只能有一个父类

  ```js
  class Person {};
  
  class Runner {
    running() {};
  };
  
  class Student extends Person, Runner {};
  ```

  - 这样写是报错的

- 不能这样写，但是我们还想让Student这个类有Runner的效果

  ```js
  class Person {};
  
  function mixinRunner(BaseClass) {
    return class NewClass extends BaseClass {
      running() {
        console.log("running");
      };
    };
  };
  function mixinEater(BaseClass) {
    return class extends BaseClass {
      eating() {
        console.log("eating");
      };
    };
  };
  
  class Student extends Person {};
  
  var NewStudent = mixinEater(mixinRunner(Student));
  var ns = new NewStudent();
  ns.running();  // running
  ns.eating();  // eating
  ```

- 这是通过js实现混入的一种方式，但是它是有弊端的，这种方式实现混入不太多，了解就行

### 3.react中的一段代码（高阶组件）

![image-20220309100032540](https://s2.loli.net/2022/03/09/9W8LEco3QeaTg7v.png)

- 现在我们有一个组件TopBanner

  ```js
  class TopBanner extends Component {};
  ```

- 我们还有redux，redux就相当于Vue中的vuex

  - 在redux中有很多的状态，我们想把这些状态添加到TopBanner组件中
  - 我们现在准备说的是传统方式应该怎么办，现在有了hooks，使用useSelector就可以获取状态
  - 我们以前必须借助于redux中提供的一个函数：connect

- 你需要把你需要映射的东西给connect(props, dispatch)，你在组件中就可以这样调这个函数，掉完这个函数它会给你返回一个新的函数，你可以继续调connect(props, dispatch)();这种方式眼熟不？柯里化函数

- 我们可以将组件传进这个返回的函数connect(props, dispatch)(TopBanner);那么这个函数内部是怎么实现的呢？

  - 我们会return一个新的class

    ```js
    return class EnhanceComponent extends PureComponent {};
    ```

  - 你给我传入一个组件，我给你返回一个新的class组件

  - 我们还需要在render函数里面，使用一下之前传入的TopBanner这个组件，我还要把传入的props和dispatch传给它

    ```js
    return class EnhanceComponent extends PureComponent {
      render() {
        return <TopBanner props dispatch>
      }
    };
    ```

  - 当我们使用TopBanner时，使用的其实是我们这里的新的组件，也就是这个EnhanceComponent增强的组件

  - 在使用EnhanceComponent增强组件时，其实在render函数中已经在使用TopBanner组件了，并且已经把props和dispatch传进去了

- 整个代码与之前的实现混入的不同是，它重写了render函数，并且把props和dispatch放了进去

  - 这意味着，props和dispatch会被间接的传入到TopBanner组件的props中

### 4.多态

- 不同的数据类型，进行同一个操作，表现出不同的行为
- 传统的面向对象的编程语言：Java、C++、typescript
- 上面提到的语言，多态是如何表现的呢？
- JS是动态类型语言，就是比较灵活，灵活有它的好处，也有坏处
  - 坏处：代码存在风险

### 5.传统意义上的多态

```js
// 图形
class Shape {
  // 获取面积
  getArea() {}
};

// 矩形
class Rectangle extends Shape {
  getArea() {
    return 100;
  }
};

// 圆形
class Circle extends Shape {
  getArea() {
    return 200;
  }
};

// 创建一个矩形
var r = new Rectangle();
// 创建一个圆形
var c = new Circle();
// 不管是什么形状，你们都有计算面积的一个方法

// 创建一个计算面积的函数，传入的参数的类型必须是Shape类型
function calcArea(shape: Shape) {
  // 不管你传入的是r还会c，他们调用的都是Shape中的getArea方法
  // 在没有重写父类方法前，虽然是不同的数据类型进行了同一操作，但是行为都是一样的，所以不是多态的体现
  // 但是我们知道子类可以对父类的方法进行重写的，当我们重写后，再调用，就会出现不同的状态
  // 不同的数据类型，进行同一个操作，表现出不同的形态，就称之为多态
  console.log(shape.getArea());
};

// 为什么这里可以传r和c，因为矩形和原型继承自Shape，所以r和c本身也是Shape类型
calcArea(r);
calcArea(c);
```

- 传统意义上的多态有三个前提

  1. 必须有继承（继承是多态的前提），但是js中没有这个必要

  2. 必须有重写，只有子类重写了方法，才能表现出不同的形态

  3. 父类的引用，指向子类对象

     ```js
     function calcArea(shape: Shape) {
       console.log(shape.getArea());
     };
     
     calcArea(r);
     calcArea(c);
     ```

     - 这里其实是把r赋值给了shape，相当于下面的代码

       ```js
       var shape: Shape = r;
       // 即
       var shape: Shape = new Rectangle();
       // 本来我们应该这么写，但是为了体现出多态，只要求传入一个形状就可以了，就是上面的写法
       var shape: Rectangle = new Rectangle();
       ```

     - var shape: Shape这个就称之为父类的引用

     - = new Rectangle();这个就称之为：指向子类对象

### 6.js的面向对象多态

```js
var obj1 = {
  name: "why",
  getArea() {
    return 2000
  },
};

class Person {
  getArea() {
    return 1000
  }
};

var p = new Person();

function calcArea(foo) {
  console.log(foo.getArea());
};

calcArea(obj1);
calcArea(p);
```

- 符不符合多态的定义：不同的数据类型，执行相同的操作，产生不同的形态（行为）
  - 符合

```js
function sum(m, n) {
  return m + n;
};

sum(10, 20);
sum("abc", "cba");
```

- 这个符不符合多态的定义？符合，也是多态的体现
- 与传统的相比，更加灵活