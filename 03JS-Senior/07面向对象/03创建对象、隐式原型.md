### 1.创建对象的方案（不推荐）

- 通过字面量的方式创建对象

  ```js
  var p1 = {
    name: "张三",
    age: 18,
    height: 1.88,
    address: "广州",
    eating: function() {
      console.log(this.name, "在吃东西~");
    },
    sporting: function() {
      console.log(this.name, "在运动~");
    },
  };
  
  var p2 = {
    name: "李四",
    age: 19,
    height: 1.78,
    address: "北京",
    eating: function() {
      console.log(this.name, "在吃东西~");
    },
    sporting: function() {
      console.log(this.name, "在运动~");
    },
  };
  
  var p3 = {
    name: "王五",
    age: 20,
    height: 1.68,
    address: "上海",
    eating: function() {
      console.log(this.name, "在吃东西~");
    },
    sporting: function() {
      console.log(this.name, "在运动~");
    },
  };
  ```

  - 这种创建对象的方式存在大量的重复代码
  - 这不是一个好的方案

- 工厂模式

  ```js
  function createPerson(name, age, height, address) {
    return {
      name,
      age,
      height,
      address,
      eating: function() {
        console.log(this.name + "正在吃饭");
      },
      sporting: function() {
        console.log(this.name + "正在运动");
      },
    };
  };
  
  var p1 = createPerson("张三", 18, 1.88, "广州");
  var p2 = createPerson("李四", 19, 1.78, "北京");
  var p3 = createPerson("王五", 20, 1.68, "上海");
  
  console.log(p1, p2, p3);
  ```

  - 获取不到对象最真实的类型

### 2.构造函数

- 构造函数也称之为构造器（constructor），在创建对象的时候调用此函数

- 在其他面向对象的编程语言里，构造函数是存在于类中的一个方法，称之为构造方法

- 在JavaScript中，构造函数是一个普通的函数

  - 但是如果这个函数使用了new操作符进行了调用，那么这个函数就被称之为构造函数

    ```js
    function foo() {};
    
    // 这样调用，foo就是一个普通的函数
    foo();
    
    // 使用new操作符进行调用，foo就是一个构造函数
    new foo();
    ```
    
    - new foo()加小括号的原因是：传递参数
- 你也可以直接new foo
  
- 通过new调用一个函数与普通的函数调用有什么区别呢？

  1. 在内存中创建一个新的空对象

  2. 这个对象内部的[[prototype]]属性会被赋值为该构造函数的prototype属性

  3. 构造函数内部的this，会指向创建出来的新对象

  4. 执行函数的内部代码

  5. 如果构造函数内部没有返回对象，则返回创建出来的新对象

     - 如果构造函数内部返回了一个非空对象，那么创建出来的对象就会被这个非空对象覆盖，进而返回
     - 如果构造函数返回一个空对象，那么创建出来的对象也会被这个空对象覆盖，从而返回一个空对象
     - 如果构造函数返回一个值或者undefined的呢？
       - 返回创建的对象
       - 你不返回undefined，它本来也是返回undefined

     ![image-20220302151018579](https://s2.loli.net/2022/03/02/UrBLPeCKxlko2Wf.png)

     - 你会看到这个对象有一个名字，也是它的类型：foo

```js
function person(name, age, height, address) {
  this.name = name;
  this.age = age;
  this.height = height
  this.address = address;
  this.eating = function() {
    console.log(this.name + "在吃东西~");
  };
  this.sporting = function() {
    console.log(this.name + "在运动~");
  };
};

// 使用new操作符进行调用，person就是一个构造函数
var p1 = new person("张三", 18, 1.88, "广州");
console.log(p1);
var p2 = new person("李四", 19, 1.78, "北京");
console.log(p2);
```

![image-20220302152116165](https://s2.loli.net/2022/03/02/BGObIcHLelwgmNY.png)

- 这里就能拿到它p1，p2的类型

- 但是这里有一个问题，我们单独去看一下这个person函数，你是无法判断它是一个普通函数还是一个构造函数，所以一般约定俗成的将构造函数的首字母大写，来表示一个构造函数。

  ```js
  function Person(name, age, height, address) {
    this.name = name;
    this.age = age;
    this.height = height
    this.address = address;
    this.eating = function() {
      console.log(this.name + "在吃东西~");
    };
    this.sporting = function() {
      console.log(this.name + "在运动~");
    };
  };
  ```

### 3.构造函数的缺点

```js
function foo() {
  return function bar() {}
}

var foo1 = foo();
var foo2 = foo();

console.log(foo1 === foo2);
```

- foo1和foo2是同一个函数对象吗？
  - 不是
  - 因为每次调用foo都会重新创建一个bar，就相当于创建了两个空对象，一个意思

```js
function Person(name, age, height, address) {
  this.name = name;
  this.age = age;
  this.height = height
  this.address = address;
  this.eating = function() {
    console.log(this.name + "在吃东西~");
  };
  this.sporting = function() {
    console.log(this.name + "在运动~");
  };
};

var p1 = new person("张三", 18, 1.88, "广州");
var p2 = new person("李四", 19, 1.78, "北京");
```

- 这里的p1.eating和p2.eating也不是同一个函数对象，但是有必要这样做吗？
- 如果我们有一百个这样的函数，每次调用的时候都需要重新创建吗？
  - 浪费性能

### 4.隐式原型：[[prototype]]

- JavaScript中，每一个对象都有一个特殊的内置属性，这个内置属性叫：[[prototype]]

- [[prototype]]这个特殊的对象指向另外一个对象

- 我们能不能看到这个对象呢？

  - 在早期的ECMAScript中是没有一个明确的规范，去指定以什么方式可以查看这个对象

  - 但是大多数浏览器提供了一个方式可以查看这个对象

    ```js
    var obj = {name: "yt", age: 18};
    var info = {brand: "audi"};
    
    console.log(obj.__proto__);
    console.log(info.__proto__);
    ```

    ![image-20220302173026462](https://s2.loli.net/2022/03/02/sUZXbFAGCBS3gwH.png)

    ![image-20220302173038638](https://s2.loli.net/2022/03/02/cUBzp6gZMN3Jjom.png)

  - 所以你可以理解为，每次创建一个对象的时候，它都会往你对象中塞入一个`__proto__`属性

- 由于各个浏览器的实现不同，所以上面这种方式存在兼容性的问题，那怎么才能一定可以拿到这个对象呢？

  - 在ES5之后，它有了规范

    ```js
    var obj = {name: "yt", age: 18};
    var info = {brand: "audi"};
    
    console.log(Object.getPrototypeOf(obj));
    console.log(Object.getPrototypeOf(info));
    ```

  - 虽然一定能找到，但是写法太长了，不利于做测试，测试的时候用刚才的写法

- 我们一般称它为隐式原型，为什么？
  1. 这个原型看不到
  2. 我们以后也不会直接改它
  3. 我们以后也不会直接用，但是我们会利用它的底层原理，来使用它

### 5.原型有什么用？

- 当我们从一个对象中获取某一个属性时，它会触发[[get]]操作

  ```js
  var obj = { name: "yt", age: 18 };
  
  console.log(obj.age);  // 18
  ```

  1. 在当前对象中查找对应的属性，如果找到就直接使用

  2. 如果没有找到，就会沿着原型链去查找

     - 首先它会来它的[[prototype]]去查找

       ```js
       var obj = {name: "yt"};
       
       console.log(obj.age)  // undefined
       ```

     - 在原型这个对象上，没有age所以打印undefined

- 假如我往我的原型上加入age，再获取就会有这个值

  ```js
  var obj = {name: "yt"};
  obj.__proto__.age = 18;
  
  console.log(obj.age);  // 18
  ```

  - 为什么要这样？
    - 在自己这里找不到，就去原型上找
    - 方便实现继承