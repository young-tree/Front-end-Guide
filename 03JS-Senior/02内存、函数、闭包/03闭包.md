### 1.闭包的定义

- 计算机科学
  - 闭包，又称词法闭包、函数闭包
  - 是在支持头等函数的编程语言中，实现词法绑定的一种技术
  - 闭包在实现上是一个结构体，它存储了一个函数和一个与之关联的环境（相当于一个符号查找表）
    - 结构体：对象
  - 闭包跟函数最大的区别在于，当捕捉闭包的时候，它的自由变量会在捕捉时被确定，即使脱离了捕捉时的上下文，它也能照常运行
- 闭包的概念出现于60年代，最早实现闭包的程序是Scheme
  - 由于JavaScript大量的设计来源于scheme，所以JavaScript有闭包
- MDN对JavaScript闭包的解释
  - 一个函数和对其周围状态的引用捆绑在一起，这样的组合就是闭包
  - 函数被引用包围
  - 闭包可以让你在一个内层函数中访问到其外层函数的作用域
  - 在JavaScript中，每当创建一个函数，闭包就会在函数创建的同时被创建出来

### 2.如下代码的内存表现（广义上的闭包）

```js
function foo() {
  return function bar() {
    console.log("bar");
  };
};

var fn = foo();
fn();
```

- 在堆内存中创建GO

  ```js
  GO = {
    foo: 0xa00,
    fn: undefined,
  }
  ```

- 开始执行：var fn = foo();

  ```js
  // 创建属于foo的AO
  AO = {
    bar: 0xb00,
  }
  ```

  ```js
  // 执行完了foo函数，再给GO中的fn赋值
  GO = {
    foo: 0xa00,
    fn: 0xb00,
  }
  ```

- 开始执行fn();

  输出：bar

我用语言来描述一下

- 在堆内存中创建GO，在全局中发现了一个foo函数，一旦发现有函数，就会为这个函数创建一个对象，并且这个对象会有一个内存地址：0xa00
- 还有一个fn变量，由于没有执行，所以是undefined
- 开始执行，在执行上下文栈中创建全局执行上下文，让VO指向GO，一旦发现foo必然会被执行，就会做一些前期准备
  - 为foo在执行上下文栈中创建函数执行上下文，同时创建AO，开始编译foo内部的东西
    - 在foo内部有一个bar函数，一旦发现是函数，就在堆内存中开辟一个空间并创建对象，创建的对象有它的内存地址0xb00
    - 并把这个内存地址给到foo的AO中的bar属性
  - 开始真正执行foo
    - 把bar的内存地址，赋值给GO的fn变量
  - 执行完毕，出栈foo这个函数执行上下文，销毁属于它的AO对象

- 执行到fn();
  - 在执行上下文栈中创建函数执行上下文，与此同时创建属于它的AO，并编译
  - 开始真正执行bar这个函数，这里只有一个输出
  - 执行完毕，出栈bar这个函数执行上下文，销毁属于它的AO对象

### 3.改进代码（严格意义上的闭包）

```js
function foo() {
  var name = "foo";
  return function bar() {
    console.log("bar", name);
  };
};

var fn = foo();
fn();
```

- 当我们执行fn();的时候
- 属于foo的AO对象在理论上已经被销毁了，但是bar中的name依然可以使用，为什么？
- 因为闭包啊
  - 闭包由两部分组成，bar这个函数，以及它可以访问的自由变量，比如name
- 最好是函数内部要有对外部作用域自由变量的引用，才算是一个严格意义上的闭包

### 4.函数在执行过程中的内存表现

- GO中的foo指向foo的对象，foo的对象（不是foo的AO）中有父级作用域链指向GO
- foo的AO中的bar指向bar的对象，bar的对象的父级作用域指向foo的AO
- 以上是四个东西，互相不关联
- 但是接下来就开始有关联了
  - GO中的fn指向bar的对象
  - 从根出发只要有引用是不能被销毁的
  - 所以bar的对象和AO均不能被销毁
  - foo的对象本来就被根所互相引用，所以不能被销毁
  - 由于foo的AO不能被销毁，所以bar才能访问到foo的AO中的自由变量

![image-20220213071955369](https://s2.loli.net/2022/02/13/KgnMLS3f4cyqkUp.png)

### 5.考虑下面这段代码

```js
function foo() {
  console.log(name)
  var name = "foo";
  return function bar() {
    console.log("bar", name);
  };
};

var fn = foo();
fn();
foo();
```

这里打印了两次name，均为undefined

可是之前不是说foo的AO不会销毁吗？怎么第二次还是undefined？

因为第二次调用的时候，重新创建函数执行上下文，重新创建foo的AO

### 6.闭包的内存释放

- GO中的fn引用着bar的对象，bar的对象引用着foo的AO，foo的AO中的bar又引用着bar的对象

- 形成了根引用着一个，循环引用，造成foo的AO和bar的对象内存泄漏

- 为什么内存泄漏？

  - 假如所有的代码都执行完了
  - 内存中是不会销毁foo的AO和bar的对象，因为在互相引用嘛

- 怎么办？

  ```js
  fn = null;
  ```

- GC会销毁那些由根对象无法指向的对象

- 如果foo = null;就会把foo的对象也销毁掉

### 7.闭包的内存泄漏

```js
function createFnArray() {
  var arr = new Array(1024 * 1024).fill(1);
}
```

- 这个是多大的内存？
  - 1占据4个字节
  - 1024 * 1024 * 4 => 4M
  - 1我们认为它是number类型，那么number类型所占内存应是8个字节（byte），所以这里应该是8M
  - 但是js引擎，为了提高空间利用率，做了一些优化，所以比较小的数字占4个字节，即这里是4M

```js
function createFnArray() {
  var arr = new Array(1024 * 1024).fill(1);

  return function bar() {
    console.log(arr.length);
  }
}

var arrayFn = createFnArray();
```

- arr会引用我们创建的数组，数组也是对象
- GO中的arrayFn又引用着bar的对象
- createFnArray的AO中的bar引用着bar的对象，bar的对象又引用着createFnArray的AO
- 如果仅仅只是调用：createFnArray();没有东西引用它，执行完就会被销毁掉

```js
function createFnArray() {
  var arr = new Array(1024 * 1024).fill(1);

  return function bar() {
    console.log(arr.length);
  }
}

var arrayFns = [];
for(var i = 0; i < 100; i++) {
  arrayFns.push(createFnArray())
}
```

- 这里的内存有400M且不会被销毁，因为从根出发都有被引用着

  ![image-20220213144849525](https://s2.loli.net/2022/02/13/2fPBwJdG6aKCgZS.png)

```js
function createFnArray() {
  var arr = new Array(1024 * 1024).fill(1);

  return function bar() {
    console.log(arr.length);
  }
}

var arrayFns = [];
for(var i = 0; i < 100; i++) {
  arrayFns.push(createFnArray())
}

arrayFns = null;
```

- ![image-20220213145051700](https://s2.loli.net/2022/02/13/3gh96OKWwkSyMvR.png)

![image-20220213150904546](https://s2.loli.net/2022/02/13/uU1lspYDng3KiOW.png)

### 8.V8引擎的优化

```js
function foo() {
  var name = "foo"
  var age = 18
  return function bar() {
    console.log(name);
  }
}

var fn = foo();
fn();
```

- age会不会被销毁？

  - 规范中说不会
  - 但是V8引擎会把它销毁

  ![image-20220213153845891](https://s2.loli.net/2022/02/14/QcXaiGNrMTwPOD4.png)