### 1.类方法——resolve

- 现在我有一个需求，我想让resolve把一个对象作为实参传出去

  ```js
  const promise = new Promise(resolve => {
    resolve({ name: "yt" });
  });
  
  promise.then(res => {
    console.log(res);  // { name: "yt" }
  });
  ```

  但是这样写也太麻烦了些

  ```js
  const promise = Promise.resolve({name: "yt"});
  promise.then(res => {
    console.log(res);  // { name: "yt" }
  });
  ```

- 为resolve传入promise

  ```js
  Promise.resolve(new Promise(resolve => resolve(123))).then(res => console.log(res));
  ```

  打印123

- 为resolve传入实现thenable的对象

  ```js
  Promise.resolve({ then: resolve => resolve(123) }).then(res => console.log(res));
  ```
  
  打印123

### 2.类方法——reject

```js
Promise.reject("123").catch(err => console.log(err));
```

- 这里要强调的是，无论给reject传入什么值，都是一样的

  ```js
  Promise.reject(new Promise((resolve, reject) => {
    resolve("123")
  })).catch(err => console.log(err));  // Promise { '123' }
  
  Promise.reject({then(resolve, reject) {
    resolve("123")
  }}).catch(err => console.log(err));  // { then: [Function: then] }
  ```

### 3.类方法——all

```js
const p1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(123);
  }, 1000);
});

const p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(456);
  }, 2000);
});

const p3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(789);
  }, 3000);
});
```

- 我现在有一个需求，就是想等到这三个promise都变成fulfilled时，再拿到结果

  ```js
  Promise.all([p1, p2, p3, "aaa"]).then(res => {
    console.log(res);  // 三秒后打印：[ 123, 456, 789, 'aaa' ]
  });
  ```

  - 这里说明一下，这个aaa会被转成Promise作为resolve的实参

- 假如p2是reject怎么办？整个promise就是reject

  ```js
  const p1 = new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(123);
    }, 1000);
  });
  
  const p2 = new Promise((resolve, reject) => {
    setTimeout(() => {
      reject(456);
    }, 2000);
  });
  
  const p3 = new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(789);
    }, 3000);
  });
  
  Promise.all([p1, p2, p3, "aaa"]).then(res => {
    console.log(res);
  }).catch(err => {
    console.log(err);  // 两秒以后打印：456
  });
  ```

  - 两秒后还会等待一秒，如果p3也变成reject，不会打印789，只会打印456
  - 我们认为这是一个缺陷

### 4.类方法——allSettled

- 在ES11（ES2010）中为Promise添加了一个新的类方法：allSettled

- 该方法会等到所有的Promise都有结果后，才会有最终的状态

  - 就是我不管你是fulfilled状态还是rejected状态，我都会给你fulfilled结果

  - 也就是说，allSettled不会来到catch里面的

    ```js
    Promise.allSettled([p1, p2, p3, "aaa"]).then(res => {
      console.log("ddd");
      console.log(res);
    }).catch(err => {
      console.log("eee");
      console.log(err);
    });
    /*
    ddd
    [
      { status: 'fulfilled', value: 123 },
      { status: 'rejected', reason: 456 },
      { status: 'fulfilled', value: 789 },
      { status: 'fulfilled', value: 'aaa' }
    ]
    */
    ```

    - 结果是一个数组，数组中有一个个对象，每个对象都有状态和对应的值
    - 如果你的状态是fulfilled，我就在value中给你结果
    - 如果你的状态是rejected，我就在reason中给你结果

### 5.类方法——race

- race：竞技、比赛、竞争

  - 谁先有结果，我们就决定先录取谁

    ```js
    Promise.race([p1, p2, p3]).then(res => {
      console.log("ddd");
      console.log(res);
    }).catch(err => {
      console.log("eee");
      console.log(err);
    });
    ```

    假如没有变化，就打印：ddd  123

    如果第一个改成两秒，第二个改成1秒，就打印：eee  456

    如果有rejected状态，就进入catch

### 6.类方法——any

- 我会等到你有fulfilled状态的时候再执行then方法

  ```js
  const p1 = new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(123);
    }, 2000);
  });
  
  const p2 = new Promise((resolve, reject) => {
    setTimeout(() => {
      reject(456);
    }, 1000);
  });
  
  const p3 = new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(789);
    }, 3000);
  });
  
  Promise.any([p1, p2, p3]).then(res => {
    console.log("ddd");
    console.log(res);
  }).catch(err => {
    console.log("eee");
    console.log(err);
  });
  ```

  - 两秒后打印456，再过一秒退出程序

- 如果全都是拒绝呢？

  ```js
  const p1 = new Promise((resolve, reject) => {
    setTimeout(() => {
      reject(123);
    }, 2000);
  });
  
  const p2 = new Promise((resolve, reject) => {
    setTimeout(() => {
      reject(456);
    }, 1000);
  });
  
  const p3 = new Promise((resolve, reject) => {
    setTimeout(() => {
      reject(789);
    }, 3000);
  });
  
  Promise.any([p1, p2, p3]).then(res => {
    console.log("ddd");
    console.log(res);
  }).catch(err => {
    console.log("eee");
    console.log(err);  // [AggregateError: All promises were rejected]
  });
  ```

  - [AggregateError: All promises were rejected]这个相当于reject(new AggregateError())

  - 你也可以拿到错误信息

    ```js
    Promise.any([p1, p2, p3]).then(res => {
      console.log(res);
    }).catch(err => {
      console.log(err.errors);  // [ 123, 456, 789 ]
    });
    ```

    