### 1.为什么使用this

- 在某些角度下，开发中不使用this，很多问题还是存在解决方案的

  ```js
  var obj1 = {
    name: "why",
    eating: function() {
      console.log(this.name + "在吃东西");
    },
    running: function() {
      console.log(this.name + "在跑步");
    },
    studying: function() {
      console.log(this.name + "在学习");
    },
  };
  
  var obj2 = {
    name: "why",
    eating: function() {
      console.log(obj2.name + "在吃东西");
    },
    running: function() {
      console.log(obj2.name + "在跑步");
    },
    studying: function() {
      console.log(obj2.name + "在学习");
    },
  };
  
  obj1.eating();
  obj1.running();
  obj1.studying();
  
  obj2.eating();
  obj2.running();
  obj2.studying();
  ```

- 但是如果你把obj2的名字改为info，就需要你手动修改每一个方法里的名字

- 而this就不需要这样做，开发起来更加方便

### 2.在全局作用域中this的指向

- 在浏览器中this指向window

  ```js
  console.log(this);
  console.log(window);
  ```

- 在node中this指向空对象

  - 在node中没有window

### 3.在函数中使用this

- 所有的函数在被调用时都会创建一个执行上下文

- 这个上下文中记录着函数的调用栈、AO对象等
- this也是其中一条记录
- 这个this是动态绑定的，什么是动态绑定？
  - 只有函数被调用时，才会确定this的指向
  - 并不是在函数编译的时候就确定

```js
function foo() {
  console.log(this);
};

// 1.直接调用
foo();

// 2.创建一个对象，用对象进行调用
var obj = {
  name: "yt",
  foo,
}

obj.foo();

// 3.apply和call
foo.apply("abc");
foo.call("cba");
```

![image-20220213191435687](https://s2.loli.net/2022/02/13/mON9wtUzWQC6BZn.png)

- this指向什么，与函数所处的位置是没有关系的，主要跟函数如何被调用有关

### 4.this的指向规则

- 默认指向
- 隐式指向
- 显示指向
- new指向

### 5.默认指向

- 函数被独立调用（this指向window）

- 案例一：

  ```js
  function foo() {
    console.log(this);
  };
  foo();
  ```

- 案例二：

  ```js
  function foo1() {
    console.log(this);
  };
  
  function foo2() {
    console.log(this);
    foo1()
  };
  
  function foo3() {
    console.log(this);
    foo2();
  };
  
  foo3();
  ```

- 案例三：

  ```js
  function foo() {
    console.log(this);
  };
  
  
  var obj = {
    name: "yt",
    foo,
  }
  
  var bar = obj.foo;
  
  bar();
  ```

- 案例四：

  ```js
  function foo() {
    var name = "yt";
    return function bar() {
      console.log(this);
    };
  };
  
  const fn = foo();
  fn();
  ```

### 6.隐式指向

- 函数的另外一种比较常见的调用方式是：通过某个对象进行调用

  - 通过某个对象发起的函数调用

- 案例一：

  ```js
  function foo() {
    console.log(this);
  };
  
  var obj = {
    name: "yt",
    foo,
  };
  
  obj.foo();  // 指向obj
  ```

- 案例二：

  ```js
  var obj1 = {
    foo: function() {
      console.log(this);
    },
  };
  
  var obj2 = {
    name: "yt",
    bar: obj1.foo,
  };
  
  obj2.bar();
  ```

### 7.显示指向

- JavaScript所有的函数都可以使用call和apply方法

  - call和apply的第一个参数都是对象
  - call除了第一个参数，其他参数是单蹦的
  - apply除了第一个参数，第二个参数是数组

- 第一个参数是对象，这个对象就是为this准备的

- 在使用的时候会将函数的this指向第一个参数的对象

- 函数被调用的方式

  ```js
  function foo() {
    console.log("函数被调用");
  };
  
  foo();
  foo.call();
  foo.apply();
  ```

- call和apply是可以指定函数的this指向哪个对象

  ```js
  function foo(num1, num2) {
    console.log("函数被调用", this.name, num1 + num2);
  };
  
  var obj = {
    name: "yt",
  };
  foo.call(obj, 1, 2);
  foo.apply(obj, [1, 2]);
  ```

- bind

  ```js
  function foo(num1, num2) {
    console.log("函数被调用", this.name, num1 + num2);
  };
  
  var obj = {
    name: "yt",
  };
  
  foo.call(obj, 1, 2);
  foo.call(obj, 1, 2);
  foo.call(obj, 1, 2);
  foo.call(obj, 1, 2);
  ```

  - 如上代码，调用时比较麻烦，有没有更好一点的调用方式呢？

    ```js
    function foo(num1, num2) {
      console.log("函数被调用", this.name, num1 + num2);
    };
    
    var obj = {
      name: "yt",
    };
    
    var abc = foo.bind(obj, 1, 2);
    abc();
    abc();
    abc();
    ```

    - 当我们调用abc的时候，foo的this永远指向obj
    - 显示指向的优先级比默认指向的优先级高

### 8.new指向

- JavaScript中的函数可以当做一个类的构造函数来使用，也就是使用new关键字

- 使用new关键字来调用函数时，会执行如下操作

  - 创建一个全新的对象
  - 这个新对象会被执行prototype连接
  - 函数的this会指向这个新对象
  - 如果函数没有返回其他对象，函数会返回这个新对象

  ```js
  function Person(name, age) {
    this.name = name;
    this.age = age;
  };
  
  const person1 = new Person("yt", 18);
  console.log(person1);
  
  const person2 = new Person("why", 18);
  console.log(person2);
  ```

  ![image-20220214074048004](https://s2.loli.net/2022/02/14/t2oynFi4kv95Qq1.png)

