### 1.箭头函数

- 在ES6中增加的一种新的编写函数的方式，它比函数表达式更加简洁

- 箭头函数中不会为this绑定对象，也不会为arguments绑定对象

  - 或者说, 箭头函数内部根本就没有this和arguments

- 箭头函数不能作为构造函数来使用：不能和new一起使用（抛出错误）

- 当箭头函数简写为一行的时候，返回值为这一行的运行结果

  - 拿到数组的所有偶数项，把每个偶数项乘以10，再把每一个数值相加

    ```js
    var num = [1, 4, 8, 20, 3];
    
    var result = num.filter(item => item % 2 === 0).map(item => item * 10).reduce((a, b) => a + b, 0);
    console.log(result);
    ```

- 当箭头函数简写为一行且返回的是一个对象的时候，如何简写？

  ```js
  var bar = () => ({ name: "yt" });
  ```

### 2.箭头函数和this

- 遇到箭头函数就把所有的东西全部忘记

- 就记一句话：this指向上层作用域

  ```js
  var foo = () => {
    console.log(this);
  };
  
  var obj = {
    foo,
  };
  
  foo();
  obj.foo();
  foo.call("abc");
  foo.apply("abc");
  var bar = foo.bind("abc");
  bar();
  ```

  - 全部返回window

- 举例

  ```js
  var obj = {
    data: [],
    foo: function() {
      setTimeout(() => {
        this.data.push(12)
      }, 1000)
    }
  };
  
  obj.foo();
  
  setTimeout(() => {
    console.log(obj.data);
  }, 2000);
  ```

### 3.面试题一

```js
var name = "window";

var person = {
  name: "person",
  sayName: function() {
    console.log(this.name);
  },
};

function sayName() {
  var sss = person.sayName;
  sss();
  person.sayName();
  (person.sayName)();
  (b = person.sayName)();
};

sayName();
```

```js
// window
// person
// person
// window
```

### 4.面试题二

```js
var name = 'window'
var person1 = {
  name: 'person1',
  foo1: function () {
    console.log(this.name)
  },
  foo2: () => console.log(this.name),
  foo3: function () {
    return function () {
      console.log(this.name)
    }
  },
  foo4: function () {
    return () => {
      console.log(this.name)
    }
  }
}

var person2 = { name: 'person2' }

person1.foo1(); 
person1.foo1.call(person2); 

person1.foo2();
person1.foo2.call(person2);

person1.foo3()();
person1.foo3.call(person2)();
person1.foo3().call(person2);

person1.foo4()();
person1.foo4.call(person2)();
person1.foo4().call(person2);
```

```js
// person1
// person2

// window
// window

// window
// window
// person2

// person1
// person2
// person1
```

### 5.面试题三

```js
var name = 'window'
function Person (name) {
  this.name = name
  this.foo1 = function () {
    console.log(this.name)
  },
  this.foo2 = () => console.log(this.name),
  this.foo3 = function () {
    return function () {
      console.log(this.name)
    }
  },
  this.foo4 = function () {
    return () => {
      console.log(this.name)
    }
  }
}
var person1 = new Person('person1')
var person2 = new Person('person2')

person1.foo1()
person1.foo1.call(person2)

person1.foo2()
person1.foo2.call(person2)

person1.foo3()()
person1.foo3.call(person2)()
person1.foo3().call(person2)

person1.foo4()()
person1.foo4.call(person2)()
person1.foo4().call(person2)
```

```js
// person1
// person2

// person1
// person1

// window
// window
// person2

// person1
// person2
// person1
```

### 6.面试题四

```js
var name = 'window'
function Person (name) {
  this.name = name
  this.obj = {
    name: 'obj',
    foo1: function () {
      return function () {
        console.log(this.name)
      }
    },
    foo2: function () {
      return () => {
        console.log(this.name)
      }
    }
  }
}
var person1 = new Person('person1')
var person2 = new Person('person2')

person1.obj.foo1()()  
person1.obj.foo1.call(person2)()  
person1.obj.foo1().call(person2)  

person1.obj.foo2()()  
person1.obj.foo2.call(person2)()  
person1.obj.foo2().call(person2)  
```

```js
// window
// window
// person2

// obj
// person2
// obj
```

### 7.注意

- 优先级是对于一个对象经过两种调整this的指向，做出的等级
- 而单独拿出来的单独说，没有优先级的概念