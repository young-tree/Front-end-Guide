### 1.setTimeout中的this

```js
setTimeout(function() {
  console.log(this);
}, 1000);
```

- 这里的this取决于setTimeout如何调用我们传入的这个函数
- 那么setTimeout如何调用我们的函数呢？应该是直接调用的，因为打印出来的是window对象
- 但是好像不是直接调用的，应该是apply(window);

### 2.监听点击

```html
<div class="div"></div>

<script>
  var clickDiv = document.querySelector(".div");
  clickDiv.onclick = function () {
    console.log(this);
  };
</script>
```

- clickDiv是一个对象，这个对象里有一个属性为onclick

- 我们给这个onclick赋值了一个函数，那么我们赋值的这个函数是怎么被调用的呢？

- 大概率是clickDiv.onclick();

- 所以this指向clickDiv这个对象

  ![image-20220214142423499](https://s2.loli.net/2022/02/14/OYEJAVr9DLyFcCe.png)

```js
clickDiv.addEventListener("click", function() {
  console.log(this);
});
clickDiv.addEventListener("click", function() {
  console.log(this);
});
clickDiv.addEventListener("click", function() {
  console.log(this);
});
```

- addEventListener可以有好几个，onclick只能有一个，有多个的话后面的会把前面的覆盖掉

- 它大概率是把我们传入的函数收集到一个数组中，依次调用执行

  ```js
  fn.call(clickDiv);
  ```

### 3.数组

- forEach

  ```js
  var names = ["abc", "cba", "nba"];
  names.forEach(function(item) {
    console.log(this);
  });
  ```
  - 打印window，应该是函数的独立调用

  - forEach也可以传递第二个参数，传什么参数，我们函数中的this就指向什么

    ```js
    var names = ["abc", "cba", "nba"];
    names.forEach(function(item) {
      console.log(this);
    }, "abc");
    ```

    - this指向abc

- 其他也是一样的

### 4.this指向的优先级

- 默认指向优先级最低

- 显示指向高于隐式指向

  ```js
  var obj = {
    name: "yt",
    foo: function() {
      console.log(this);
    },
  };
  
  obj.foo();
  obj.foo.call("abc");
  obj.foo.apply("abc");
  ```

  ```js
  function foo() {
    console.log(this);
  }
  
  var obj = {
    name: "yt",
    foo: foo.bind("abc"),
  };
  
  obj.foo();
  ```

- new指向高于隐式指向

  ```js
  var obj = {
    name: "yt",
    foo: function() {
      console.log(this);
    },
  };
  
  var fn = new obj.foo();
  ```

- new指向高于bind

  - new和call以及apply是不能一同使用的

  ```js
  function foo() {
    console.log(this);
  };
  
  var bar = foo.bind("abc");
  new bar();
  ```

  - 打印foo

- bind高于call和apply

  ```js
  var bar = foo.bind("abc");
  bar.call("cba");
  bar.apply("cba");
  ```

- 优先级排序

  1. new指向
  2. bind
  3. call/apply
  4. 隐式指向
  5. 默认指向

### 5.特殊情况：

- 忽略显示指向：显示绑定null或者undefined，this指向window

  ```js
  function foo() {
    console.log(this);
  };
  
  foo.call(null);
  foo.apply(null);
  var bar = foo.bind(null);
  bar();
  
  foo.call(undefined);
  foo.apply(undefined);
  var bar = foo.bind(undefined);
  bar();
  ```

  - 打印：window

- 间接函数引用

  ```js
  var obj1 = {
    name: "obj1",
    foo: function() {
      console.log(this);
    },
  };
  
  var obj2 = {
    name: "obj2"
  };
  
  (obj2.foo = obj1.foo)();
  ```

  - 独立函数调用，所以打印window

  - 小插曲

    ```js
    var obj1 = {
      name: "obj1",
      foo: function() {
        console.log(this);
      },
    };
    
    var obj2 = {
      name: "obj2"
    }
    
    (obj2.foo = obj1.foo)();
    ```

    - 这段代码能否运行？

    - 会报错

    - 由于我们在倒数第三行没有分号，JavaScript认为你倒数第三行没写完

      ```js
      var obj1 = {
        name: "obj1",
        foo: function() {
          console.log(this);
        },
      };
      
      var obj2 = {
        name: "obj2"
      }(obj2.foo = obj1.foo)();
      ```

    - 这样当然会报错

      ```js
      function foo(item) {
        console.log(item, this.id);
      };
      
      var obj = {
        id: 123,
      }
      
      [1, 2, 3].forEach(foo, obj);
      ```

    - 这段代码与上面出现了相同的问题

      ```js
      function foo(item) {
        console.log(item, this.id);
      };
      
      var obj = {
        id: 123,
      };
      
      [1, 2, 3].forEach(foo, obj);
      ```

    - 这样才可以运行

