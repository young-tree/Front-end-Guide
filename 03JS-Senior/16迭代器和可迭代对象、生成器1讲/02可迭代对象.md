### 1.可迭代对象

```js
const names = [ "abc", "cba", "nba" ]

let index = 0;
const iterator = {
  next() {
    if (index < names.length) {
      return { done: false, value: names[index++] }
    } else {
      return { done: true, value: undefined }
    }
  }
}
```

- 我们想把这些东西放到一起，比如像下面的这段伪代码

  ```js
  const obj = {
    names: [ "abc", "cba", "nba" ],
    index: 0,
    iterator: 迭代器,
  };
  ```

  - 把这三个东西放到一个对象里面，并且这个对象符合我们的某个特定要求
  - 我们会把这个对象称之为可迭代对象

### 2.区分迭代器和可迭代对象

- 迭代器是一个对象，这个对象符合迭代器协议

  - 迭代器协议：iterator protocol [ˈprəʊtəkɒl] 迭代器协议

    ```js
    const iterator = { next() { return { done: false, value: "abc" } } }
    ```

- 可迭代对象与迭代器属于两个不同的概念，当然他们之间是有关系的

  - 当一个对象实现了可迭代协议（iterable protocol），它就是一个可迭代对象
  - 我们知道迭代器协议要求的是next函数，而可迭代协议的要求是什么呢？
    - 这个协议要求我们必须实现 `@@iterator` 方法

- `@@iterator` 方法是什么样的呢？

  - 以 [Symbol.iterator] 作为名字，去实现一个函数，把这个函数放到对象中就叫 `@@iterator` 方法

- 那么这个函数有什么要求呢

  - 这个函数要求我们返回一个迭代器
  - 也就是说我们在2中的第一点创建的迭代器需要在这里被返回

- 这个时候我们再把这个函数放到对象中，那么这个对象就是一个可迭代对象

  ```js
  const iterableObj = { [Symbol.iterator]: function() { return 迭代器 } };
  ```

### 3.可迭代对象的书写

- 我们最初就是想把下面的三个东西放到一个对象中

  ```js
  const names = [ "abc", "cba", "nba" ];
  
  let index = 0;
  const iterator = {
    next() {
      if (index < names.length) {
        return { done: false, value: names[index++] }
      } else {
        return { done: true, value: undefined }
      }
    }
  }
  ```

- 现在我们就尝试放一下

  ```js
  const iterableObj = {
    names: [ "abc", "cba", "nba" ],
    [Symbol.iterator]: function() {
      let index = 0;
      
      return {
        next() {
          if (index < names.length) {
            return { done: false, value: names[index++] }
          } else {
            return { done: true, value: undefined }
          }
        }
      }
    }
  }
  ```

  - 这里有一个问题，names为什么没有值？

    - 首先会在next函数中查找有没有定义names，没有
    - 其次会去[Symbol.iterator]函数中查找有没有定义names，没有
    - 最后会去全局中查找有没有定义names，没有

  - 我们在names前面加一个this可以吗？

    - 其实是不可以的，因为我们调next都是怎么调用的呢？iterator.next();

    - 所以这个this代表的是下面这个对象，而不是iterableObj

      ```js
      return {
        next() {
          if (index < this.names.length) {
            return { done: false, value: this.names[index++] }
          } else {
            return { done: true, value: undefined }
          }
        }
      }
      ```

  - 怎么办？简单啊，把next函数变成一个箭头函数啊

    ```js
    const iterableObj = {
      names: [ "abc", "cba", "nba" ],
      [Symbol.iterator]: function() {
        let index = 0;
    
        return {
          next: () => {
            if (index < this.names.length) {
              return { done: false, value: this.names[index++] }
            } else {
              return { done: true, value: undefined }
            }
          }
        }
      }
    }
    ```

    - 这个时候this指向谁呢？
    - 首先会去上一层作用域中找this，上一层作用域中的this指向谁？其实需要看怎么被调用
    - 一般都是正常调用，也就是隐式绑定，所以this指向iterableObj这个对象，所以在this中有names

  - 此时的这个对象就是一个可迭代对象

    ```js
    const iterator = iterableObj[Symbol.iterator]();
    console.log(iterator.next());
    console.log(iterator.next());
    console.log(iterator.next());
    console.log(iterator.next());
    
    /*
    { done: false, value: 'abc' }
    { done: false, value: 'cba' }
    { done: false, value: 'nba' }
    { done: true, value: undefined }
    */
    ```

### 4.可迭代对象的好处

- 我们可以多次调用iterableObj[Symbol.iterator]这个方法

- 每次调用都会创建一个全新的迭代器，可是这又有啥用呢？

  - 比如之前一直使用的for ... of，它能够遍历的东西，必须是一个可迭代对象

    - 我们尝试用for ... of遍历一个普通对象

      ```js
      const obj = {
        name: "yt",
        age: 22
      }
      
      for (const item of obj) {
        console.log(item)
      }
      ```

      ![image-20220406162615890](https://s2.loli.net/2022/04/06/Vc2bZU7M6G1NfY8.png)

    - 我们再尝试用for ... of遍历一个可迭代对象

      ```js
      for (const item of iterableObj) {
        console.log(item)
      }
      
      /*
      abc
      cba
      nba
      */
      ```

      - for ... of其实是下面这段代码的语法糖

        ```js
        const iterator = iterableObj[Symbol.iterator]();
        console.log(iterator.next().value);
        console.log(iterator.next().value);
        console.log(iterator.next().value);
        ```

        - 当然没这么简单，内部会做些判断的
        - 判断你的done到底为true还是false，当done是true的时候就停止掉

### 5.内置的可迭代对象

- 数组

  ```js
  const names = [ "abc", "cba", "nba" ];
  
  const iterator = names[Symbol.iterator]();
  console.log(iterator.next());
  console.log(iterator.next());
  console.log(iterator.next());
  for(const name of names) {
    console.log(name);
  };
  /*
  { value: 'abc', done: false }
  { value: 'cba', done: false }
  { value: 'nba', done: false }
  abc
  cba
  nba
  */
  ```

- Set

  ```js
  const set = new Set();
  set.add(10);
  set.add(100);
  set.add(1000);
  
  for (const item of set) {
    console.log(item)
  }
  /*
  10
  100
  1000
  */
  ```

- 函数中的arguments也是一个可迭代对象

  ```js
  function abc(x, y, z) {
    for (const arg of arguments) {
      console.log(arg)
    }
  }
  
  abc(10, 20, 30);
  ```

- 还有String、Map、在进行DOM操作时拿到的那个NodeList集合，都是可迭代对象

- 但是对象不是一个可迭代对象

### 6.可迭代对象的应用

- JavaScript语法：

  - for ...of

  - 展开语法（spread syntax）

    ```js
    const iterableObj = {
      names: [ "abc", "cba", "nba" ],
      [Symbol.iterator]: function() {
        let index = 0;
    
        return {
          next: () => {
            if (index < this.names.length) {
              return { done: false, value: this.names[index++] }
            } else {
              return { done: true, value: undefined }
            }
          }
        }
      }
    }
    
    const names = ["aaa", "bbb", "ccc"];
    const allname = [...names, ...iterableObj];
    console.log(allname);  // [ 'aaa', 'bbb', 'ccc', 'abc', 'cba', 'nba' ]
    ```

    ```js
    const obj = { name: "yt", age: 22 };
    const newObj = {...obj};
    console.log(newObj);
    ```

    - 我们之前说过obj是不能被for ... of遍历的，是因为它不是一个可迭代对象

    - 但是这里为什么可以进行解构呢？

    - 因为在ES9（ES2018）新加了这么一个特性，在此之前是不能这样做的

    - 这种解构不是用的可迭代对象原理

    - 可以用下面的代码实现

      ```js
      for (const entry of obj.entries) {}
      ```

      - 拿到键值对
      - 不同的js引擎，有不同的实现，但是用的不是可迭代对象

  - yield*（后面讲）

  - 解构赋值（Destructuring_assignment）；

    - 数组的解构是通过可迭代对象
    - 而对象的解构不是可迭代对象，是ES9新增的特性，用其他的方式实现的

- 创建某些对象：

  - new Set([iterable])

    ![image-20220406182406095](https://s2.loli.net/2022/04/06/HRO7SYUCATJ5aj6.png)

  - new WeakSet([iterable])

  - new Map([Iterable])

  - new WeakMap([iterable])

  - 他们需要传入的对象为可迭代对象，如果传入的不是可迭代对象，就会报错

- 一些方法的调用
  - 创建数组时，你可能会用到下面这段代码

    ```js
    const arr = Array.from(iterableObj);
    console.log(arr);  // [ 'abc', 'cba', 'nba' ]
    ```

  - Promise.all();要求传入一个可迭代对象

    ```js
    Promise.all(iterableObj).then(res => {
      console.log(res)  // [ 'abc', 'cba', 'nba' ]
    })
    ```

  - Promise.race();也要求传入一个可迭代对象


### 7.自定义类的迭代

```js
class Classroom {
  constructor(address, name, students) {
    this.address = address;
    this.name = name;
    this.students = students;
  };

  entry(student) {
    this.students.push(student);
  };

  [Symbol.iterator]() {
    let index = 0;
    return {
      next: () => {
        if (index < this.students.length) {
          return { done: false, value: this.students[index++] };
        } else {
          return { done: true, value: undefined }
        }
      },
      return() {
        console.log("被拦截！");
        return { done: true, value: undefined };
      },
    };
  };
};

const classroom = new Classroom("天河", "弘源", ["abc", "cba", "nba"]);
classroom.entry("mba");

for (const item of classroom) {
  console.log(item);
  if(item === "cba") break;
};
```

- 可迭代对象在某些情况下会在没有完全迭代的情况下中断：
  - 比如遍历的过程中通过break、continue、return、throw中断了循环操作
  - 比如在解构的时候，没有解构所有的值

