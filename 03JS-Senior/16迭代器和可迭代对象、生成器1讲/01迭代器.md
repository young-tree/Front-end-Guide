### 1.迭代器

- 迭代器是一个对象，它可以确保用户遍访容器对象存储的东西
  - 容器对象是一种数据结构，数据结构是什么呢？
    - 比如：Array、链表、哈希表
- 迭代器也是一个接口，使用该接口无需关心容器对象的内部实现细节
- 迭代器就像是一个指针，每使用一次迭代器，就会访问容器对象的某一个值或者某一个元素
- 迭代器是帮助我们对某个数据结构进行遍历的对象
- 这个对象需要符合迭代器协议（iterator protocol）
  - 让一个对象变成迭代器，需要符合迭代器协议
  - 迭代器协议定义了如何以标准的方式产生一系列值，这些值的数量可以是有限个也可以是无限个
    - 迭代器是需要产生一系列值的，因为它要访问数据结构，所以要产生一系列的值
  - 那么这个协议是什么呢？
    - 迭代器这个对象必须存在一个特定的next方法

### 2.next方法要求

- 它是一个函数，这个函数要么没有参数，要么只有一个参数

- 这个函数返回一个对象，此对象拥有两个特定的属性

  - 属性一：done
    - 如果迭代器可以产生序列中的下一值，done为false
    - 如果迭代器已经将序列迭代完毕，则为true
    - done为true时，value属性可以省略不写，但是不推荐
  - 属性二：value
    - 迭代器返回的任何JavaScript值

- 大概的一个样貌

  ```js
  const mes = [ "abc", "cba", "nba" ]
  
  const iterator = {
    next() {
      return { done: false, value: "abc"}
      return { done: false, value: "cba"}
      return { done: false, value: "nba"}
      return { done: true, value: undefined}
    }
  }
  ```

### 3.编写迭代器

```js
const iterator = {
  next() {
    return { done: false, value: 123},
  }
}
```

- 很明显这个对象目前什么也干不了

### 4.创建一个迭代器来访问数组

- 我们对数组的遍历可以通过for of

- 但是我们现在想用迭代器访问数组

  ```js
  const names = [ "abc", "cba", "nba" ]
  
  let index = 0;
  const iterator = {
    next() {
      if (index < names.length) {
        return { done: false, value: names[index++] }
      } else {
        return { done: true, value: undefined }
      }
    }
  }
  
  console.log(iterator.next());  // { done: false, value: 'abc' }
  console.log(iterator.next());  // { done: false, value: 'cba' }
  console.log(iterator.next());  // { done: false, value: 'nba' }
  console.log(iterator.next());  // { done: true, value: undefined }
  console.log(iterator.next());  // { done: true, value: undefined }
  ```

### 5.封装通用迭代器

- 这个迭代器只能针对names这一个数组，我还想针对其他数组使用迭代器

- 但是总不能再写一个吧，所以要有一个通用的迭代器

  - 我们要知道为什么要写一个通用的迭代器？
  - 即便一个一个的定义其实也能实现，但是为什么不呢？
    - 麻烦？
    - 主要是因为代码的重复逻辑太多
    - 那么什么东西可以重复利用一份代码呢？
    - 函数

- 通过函数，封装一个通用迭代器

  ```js
  function createArrayIterator(arr) {
    let index = 0;
    return {
      next() {
        if (index < arr.length) {
          return { done: false, value: arr[index++] }
        } else {
          return { done: true, value: undefined }
        }
      }
    }
  }
  
  const names = [ "abc", "cba", "nba" ]
  const namesIterator = createArrayIterator(names);
  
  console.log(namesIterator.next());
  console.log(namesIterator.next());
  console.log(namesIterator.next());
  
  const nums = [123, 321, 369];
  const numsIterator = createArrayIterator(nums);
  
  console.log(numsIterator.next());
  console.log(numsIterator.next());
  console.log(numsIterator.next());
  ```

### 6.无限的迭代器（了解）

```js
function iteratorFn() {
  let index = 0;
  return {
    next() {
      return { done: false, value: index++ }
    }
  }
}

const itrator = iteratorFn();
console.log(itrator.next());
console.log(itrator.next());
console.log(itrator.next());
console.log(itrator.next());
console.log(itrator.next());
console.log(itrator.next());
console.log(itrator.next());
```

