### 1.认识生成器

- 生成器是ES6中新增的一种函数控制和使用方案

- 它可以让我们更加灵活的控制函数

  - 控制它什么时候暂停执行

  - 控制它什么时候继续执行

  - 比如我有下面这样一个函数

    ```js
    function foo() {
      // 第一段代码
      const num1 = 100;
      console.log(num1);
    
      // 第二段代码
      const num2 = 200;
      console.log(num2);
    
      // 第三段代码
      const num3 = 300;
      console.log(num3)
    };
    ```

    - 当我们执行完第一段代码后，想要暂停，不继续往下执行了
    - 当我们暂停后又想要往下执行第二段代码
    - 上面这两个要求，生成器就可以做到

- 通常情况下我们不会单独编写一个生成器
- 生成器的出现一般伴随着生成器函数
  
  - 生成器函数的返回值是生成器

### 2.认识生成器函数

- 首先它是一个函数，但是它与普通函数还是存在一些区别

  1. 生成器函数需要在function关键字的后面加上一个符号：*

     ```js
     function* foo() {};
     ```

  2. 生成器函数可以通过yield关键字来控制函数的执行流程

     - 当然你也可以不写yield关键字，它依然是一个生成器函数

     ```js
     function* foo() {
       // 第一段代码
       const num1 = 100;
       console.log(num1);
       yield;
     
       // 第二段代码
       const num2 = 200;
       console.log(num2);
       yield;
     
       // 第三段代码
       const num3 = 300;
       console.log(num3)
     };
     
     foo();
     ```

     - 直接调用生成器函数，生成器函数中的代码一行都不会执行
     - 那么我们调用它会发生什么呢？它会给我们返回一个对象，这个对象就是生成器（也可以叫它：生成器对象）

  3. 生成器函数的返回值是生成器（generator）

     - 生成器是一个特殊的迭代器

### 3.生成器函数的使用

- 拿到生成器函数的返回值，调用生成器这个对象的next方法
- 一旦调用了生成器的next方法，就会执行yield上面的代码
- 如果第二次调用就会执行第二个yield和第一个yield之间的代码
- 如果第三次调用yield就会执行第三段代码（就这段代码来说），即执行最后一个yield后面的代码
- 如果你执行next的次数超过了yield个数+1，所执行的next函数是不会起作用的

```js
function* foo() {
  // 第一段代码
  const num1 = 100;
  console.log(num1);
  yield 1;

  // 第二段代码
  const num2 = 200;
  console.log(num2);
  yield;

  // 第三段代码
  const num3 = 300;
  console.log(num3)
};

const generator = foo();
// 开始执行第一段代码
generator.next();  // 100
generator.next();  // 200
generator.next();  // 300
generator.next();  // 程序运作已经结束
```

### 4.生成器的返回值

- 我们之前学过迭代器的next方法，它是有返回值的，返回一个特殊的对象

- 所以这里的generator.next()是有返回值的

  ```js
  console.log(generator.next());
  console.log(generator.next());
  console.log(generator.next());
  console.log(generator.next());
  
  /*
  100
  { value: 1, done: false }
  200
  { value: undefined, done: false }
  300
  { value: undefined, done: true }
  { value: undefined, done: true }
  */
  ```

  - 有几个yield就有几个false，所以总共两个yield，两个false
  - yield后可以跟一个值，作为value

### 5.传递参数

```js
function* foo() {
  // 第一段代码
  const num1 = 100;
  console.log(num1);
  const n = yield 1;

  // 第二段代码
  console.log(n);
  const num2 = 200;
  console.log(num2);
  yield;

  // 第三段代码
  const num3 = 300;
  console.log(num3)
};
```

- 我想在第二段代码中拿到传入的n，应该怎么传？

  ```js
  const generator = foo();
  // 开始执行第一段代码
  console.log(generator.next());
  console.log(generator.next(10));
  console.log(generator.next());
  console.log(generator.next());
  ```

  - 哈！没想到吧，第一个参数要在第二个next中传
  - 不过第二个next就应该给第二段代码传参

- 我想在第一段代码中拿到某个参数，应该怎样做？

  - 当然不是直接在第一个next中传入值，因为没有yield来接收

  - 所以应该在foo中传入实参

    ```js
    function* foo(num) {
      // 第一段代码
      console.log(num);
      const num1 = 100;
      console.log(num1);
      yield 1;
    };
    
    const generator = foo(11);
    // 开始执行第一段代码
    console.log(generator.next());
    ```

### 6.return方法终止执行

- next方法很常用，但是return方法和throw方法用的比较少

  ```js
  function* foo() {
    // 第一段代码
    const num1 = 100;
    console.log(num1);
    yield 1;
  
    // 第二段代码
    const num2 = 200;
    console.log(num2);
    yield;
  
    // 第三段代码
    const num3 = 300;
    console.log(num3)
  };
  
  const generator = foo(11);
  // 开始执行第一段代码
  console.log(generator.next());
  console.log(generator.return(15));
  console.log(generator.next());
  console.log(generator.next());
  /*
  100
  { value: 1, done: false }
  { value: 15, done: true }
  { value: undefined, done: true }
  { value: undefined, done: true }
  */
  ```

- 相当于下面这段代码

  ```js
  function* foo() {
    // 第一段代码
    const num1 = 100;
    console.log(num1);
    const n = yield 1;
    return n;
  
    // 第二段代码
    const num2 = 200;
    console.log(num2);
    yield;
  
    // 第三段代码
    const num3 = 300;
    console.log(num3)
  };
  ```

  - 第二段代码是不会执行的，后面的代码也会终止掉

### 7.throw方法抛出异常

```js
function* foo() {
  // 第一段代码
  const num1 = 100;
  console.log(num1);
  yield 1;

  // 第二段代码
  const num2 = 200;
  console.log(num2);
  yield;

  // 第三段代码
  const num3 = 300;
  console.log(num3)
};

const generator = foo(11);
// 开始执行第一段代码
console.log(generator.next());
console.log(generator.throw());
console.log(generator.next());
console.log(generator.next());
```

- 开始执行第二段代码的时候就报错了

- 但是如果你在第二段代码伊始进行了异常的捕获，代码就可以继续往下执行

  ```js
  function* foo() {
    // 第一段代码
    const num1 = 100;
    console.log(num1);
  
    try {
      yield 1
    } catch(err) {
      console.log("捕获到异常情况", err)
    }
  
    // 第二段代码
    const num2 = 200;
    console.log(num2);
    yield;
  
    // 第三段代码
    const num3 = 300;
    console.log(num3)
  };
  
  const generator = foo(11);
  // 开始执行第一段代码
  console.log(generator.next());
  console.log(generator.throw("error message"));
  console.log(generator.next());
  console.log(generator.next());
  
  /*
  100
  { value: 1, done: false }
  捕获到异常情况 error message
  200
  { value: undefined, done: false }
  300
  { value: undefined, done: true }
  { value: undefined, done: true }
  */
  ```

- 如果你在catch中也写了yield是可以

  ```js
  function* foo() {
    // 第一段代码
    const num1 = 100;
    console.log(num1);
  
    try {
      yield 1
    } catch(err) {
      console.log("捕获到异常情况", err);
      yield "abc"
    }
  
    // 第二段代码
    const num2 = 200;
    console.log(num2);
    yield;
  
    // 第三段代码
    const num3 = 300;
    console.log(num3)
  };
  
  const generator = foo(11);
  // 开始执行第一段代码
  console.log(generator.next());
  console.log(generator.throw("error message"));
  console.log(generator.next());
  console.log(generator.next());
  /*
  100
  { value: 1, done: false }
  捕获到异常情况 error message
  { value: 'abc', done: false }
  200
  { value: undefined, done: false }
  300
  { value: undefined, done: true }
  */
  ```

  