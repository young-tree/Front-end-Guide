### 1.正确的收集依赖

```js
class Depend {
  constructor() {
    this.reactiveFns = [];
  };

  addDepend(reactiveFn) {
    this.reactiveFns.push(reactiveFn)
  };

  notifyDepend() {
    this.reactiveFns.forEach(item => {
      item();
    });
  }
};

// 修改了这里
function watchFn(fn) {
  fn();
};

const targetMap = new WeakMap();
function getDepend(target, key) {
  let map = targetMap.get(target);
  if(!map) {
    map = new Map();
    targetMap.set(target, map);
  };

  let depend = map.get(key);
  if(!depend) {
    depend = new Depend();
    map.set(key, depend);
  };

  return depend;
};

const obj = {
  name: "why",
  age: 18,
};

const objProxy = new Proxy(obj, {
  get: function(target, key, receiver) {
    return Reflect.get(target, key, receiver);
  },
  set: function(target, key, newValue, receiver) {
    Reflect.set(target, key, newValue, receiver);
    const depend = getDepend(target, key);
    depend.notifyDepend();
  },
});

watchFn(function() {
  console.log(objProxy.name);
});

watchFn(function() {
  console.log(objProxy.age);
});

watchFn(function() {
  console.log(objProxy.name);
});

objProxy.name = "yt";
```

- 我们来分析一下这段代码

- 首先console.log(objProxy.name);一旦通过objProxy对象获取name属性，就会来到objProxy的get属性中，并执行这个get方法

- 如果这个get方法被执行，我们可以拿到这个target，这个target是obj，还有key，这个key是name

- 那就意味着我可以调用getDepend函数，并传入target和key，根据这两个就可以获取对应的depend

- 如果我执行的是console.log(objProxy.age);那么也可以做到这一点

- 根据这两个就可以获取到一个属于他自己的唯一一个depend

- 然后给我们的depend对象中添加响应函数：depend.addDepend()

- 这里有一个问题，你能把拿到的函数放到里面吗？不能

- 我们可以使用一个技巧，在全局定义一个变量，设置为null，然后在watchFn函数中把参数fn赋值给全局变量

- 这样在我们每次执行get方法的时候就可以拿到这个被反复赋值的全局变量

  ```js
  let activeReactiveFn = null;
  function watchFn(fn) {
    activeReactiveFn = fn;
    fn();  // 初始化执行
    activeReactiveFn = null;  // 为了watchFn在被调用的时候，不传参，防止乱添加
  };
  
  const objProxy = new Proxy(obj, {
    get: function(target, key, receiver) {
      const depend = getDepend(target, key);
      depend.addDepend(activeReactiveFn);
      return Reflect.get(target, key, receiver);
    },
  });
  ```

  - 写到这里会有一个疑问，就是整个过程我们只是把需要加入响应式的函数执行了一次，然后再根据里面是否有依赖到某个属性，然后再把这个函数加入到正确的depend对象中的数组中

  - 也就是说只有函数中有某个需要依赖的属性，才会被加入到响应式中。假如函数中没有objProxy.name那么这个函数是不会被加入进depend的，只会在初始时执行一次

    ```js
    class Depend {
      constructor() {
        this.reactiveFns = [];
      };
    
      addDepend(reactiveFn) {
        this.reactiveFns.push(reactiveFn)
      };
    
      notifyDepend() {
        this.reactiveFns.forEach(item => {
          item();
        });
      }
    };
    
    let activeReactiveFn = null;
    function watchFn(fn) {
      activeReactiveFn = fn;
      fn();
      activeReactiveFn = null;
    };
    
    const targetMap = new WeakMap();
    function getDepend(target, key) {
      let map = targetMap.get(target);
      if(!map) {
        map = new Map();
        targetMap.set(target, map);
      };
    
      let depend = map.get(key);
      if(!depend) {
        depend = new Depend();
        map.set(key, depend);
      };
    
      return depend;
    };
    
    const obj = {
      name: "why",
      age: 18,
    };
    
    const objProxy = new Proxy(obj, {
      get: function(target, key, receiver) {
        const depend = getDepend(target, key);
        depend.addDepend(activeReactiveFn);
        return Reflect.get(target, key, receiver);
      },
      set: function(target, key, newValue, receiver) {
        Reflect.set(target, key, newValue, receiver);
        const depend = getDepend(target, key);
        depend.notifyDepend();
      },
    });
    
    watchFn(function() {
      console.log(objProxy.name);
    });
    
    watchFn(function() {
      console.log(objProxy.age);
    });
    
    watchFn(function() {
      console.log(objProxy.name);
    });
    
    objProxy.name = "yt";
    objProxy.age = 22;
    
    /*
    why
    18
    why
    yt
    yt
    22
    */
    ```

### 2.优化

```js
const objProxy = new Proxy(obj, {
  get: function(target, key, receiver) {
    const depend = getDepend(target, key);
    depend.addDepend(activeReactiveFn);
    return Reflect.get(target, key, receiver);
  },
});
```

- 对于这里的depend.addDepend(activeReactiveFn);我们认为比较麻烦

- 我们想要这么做：depend.depend();

  ```js
  let activeReactiveFn = null;
  
  class Depend {
    constructor() {
      this.reactiveFns = [];
    };
  
    depend() {
      if(activeReactiveFn) {
        this.reactiveFns.push(activeReactiveFn);
      };
    };
  };
  
  function watchFn(fn) {
    activeReactiveFn = fn;
    fn();
    activeReactiveFn = null;
  };
  
  const objProxy = new Proxy(obj, {
    get: function(target, key, receiver) {
      const depend = getDepend(target, key);
      depend.depend();
      return Reflect.get(target, key, receiver);
    },
  });
  ```

### 3.还存在问题

```js
watchFn(function() {
  console.log(objProxy.name);
  console.log(objProxy.name);
});

objProxy.name = "abc";
```

- 像这样的代码需要执行两次吗？显然是不需要的

- 为什么会出现这样的问题呢？因为它遇见objProxy.name就会被添加到那个数组中，所以这个函数会被添加两次

- 那怎么办呢？很简单呀，你让那个数组变成可去重的数组不就行了

  ```js
  class Depend {
    constructor() {
      this.reactiveFns = new Set();
    };
  
    depend() {
      if(activeReactiveFn) {
        this.reactiveFns.add(activeReactiveFn);
      };
    };
  };
  ```

### 4.对象的响应式操作

- 现在有一个问题，我们再有一个info对象，这个info对象如何才能加入响应式呢？

- 难道要再创建一个Proxy对象吗？对info再来做一个代理吗？显然是不合适的

  ```js
  function reactive(obj) {
    return new Proxy(obj, {
      get: function(target, key, receiver) {
        const depend = getDepend(target, key);
        depend.depend();
        return Reflect.get(target, key, receiver);
      },
      set: function(target, key, newValue, receiver) {
        Reflect.set(target, key, newValue, receiver);
        const depend = getDepend(target, key);
        depend.notifyDepend();
      },
    });
  }
  
  const obj = {
    name: "why",
    age: 18,
  };
  
  const objProxy = reactive(obj);
  
  watchFn(function() {
    console.log(objProxy.name);
  })
  
  objProxy.name = "abc";
  
  const info = {
    name: "yt",
    address: "济南市"
  };
  
  const infoProxy = reactive(info);
  
  watchFn(function() {
    console.log(infoProxy.name);
  })
  
  infoProxy.name = "kobe";
  ```

  - 在写法上我们还可以再优化

    ```js
    const obj = reactive({
      name: "why",
      age: 18,
    });
    
    watchFn(function() {
      console.log(obj.name);
    })
    
    obj.name = "abc";
    
    const info = reactive({
      name: "yt",
      address: "济南市"
    });
    
    watchFn(function() {
      console.log(info.name);
    })
    
    info.name = "kobe";
    ```

- 最终

  ```js
  let activeReactiveFn = null;
  
  class Depend {
    constructor() {
      this.reactiveFns = new Set();
    };
  
    depend() {
      if(activeReactiveFn) {
        this.reactiveFns.add(activeReactiveFn);
      };
    };
  
    notifyDepend() {
      this.reactiveFns.forEach(item => {
        item();
      });
    }
  };
  
  function watchFn(fn) {
    activeReactiveFn = fn;
    fn();
    activeReactiveFn = null;
  };
  
  const targetMap = new WeakMap();
  function getDepend(target, key) {
    let map = targetMap.get(target);
    if(!map) {
      map = new Map();
      targetMap.set(target, map);
    };
  
    let depend = map.get(key);
    if(!depend) {
      depend = new Depend();
      map.set(key, depend);
    };
  
    return depend;
  };
  
  function reactive(obj) {
    return new Proxy(obj, {
      get: function(target, key, receiver) {
        const depend = getDepend(target, key);
        depend.depend();
        return Reflect.get(target, key, receiver);
      },
      set: function(target, key, newValue, receiver) {
        Reflect.set(target, key, newValue, receiver);
        const depend = getDepend(target, key);
        depend.notifyDepend();
      },
    });
  }
  
  const obj = reactive({
    name: "why",
    age: 18,
  });
  
  watchFn(function() {
    console.log(obj.name);
  })
  
  obj.name = "abc";
  
  const info = reactive({
    name: "yt",
    address: "济南市"
  });
  
  watchFn(function() {
    console.log(info.name);
  })
  
  info.name = "kobe";
  ```

### 5.Vue2响应式原理

- 之前学习的是Vue3采用的响应式原理，通过Proxy和Reflect实现

- 那么在ES6之前是什么样子的呢？也就是Vue2如何实现的响应式原理呢？

  ```js
  function reactive(obj) {
    return new Proxy(obj, {
      get: function(target, key, receiver) {
        const depend = getDepend(target, key);
        depend.depend();
        return Reflect.get(target, key, receiver);
      },
      set: function(target, key, newValue, receiver) {
        Reflect.set(target, key, newValue, receiver);
        const depend = getDepend(target, key);
        depend.notifyDepend();
      },
    });
  }
  ```

  - 区别主要在于这个对象，它对于对象的拦截采用的不是Proxy，而是Object.defineProporty

    ```js
    function reactive(obj) {
      for(const key in obj) {
        let value = obj[key];
        Object.defineProperty(obj, key, {
          get: function() {
            const depend = getDepend(obj, key);
            depend.depend();
            return value;
          },
          set: function(newValue) {
            value = newValue;
            const depend = getDepend(obj, key);
            depend.notifyDepend()
          },
        });
      };
      
      return obj;
    };
    ```

    - 这里不是很推荐使用for in，因为这个并不是在ES6之前就规范化了，所以Vue2用的是Object.keys(obj).forEach(key => {})