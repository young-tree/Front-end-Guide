### 1.有一段代码和需求

```js
let m = 100;

console.log(m);
console.log(m * 2);
console.log(m ** 3);
```

- 我们希望当m发生了变化之后，所有用到m的地方都要跟着进行改变

- 比如我在最下面添加了 m = 200; 之后刚才的三个打印要重新以200进行计算和打印

- 不过重新执行的代码不一定与m必须相关

  ```js
  let m = 100;
  
  console.log(m);
  console.log(m * 2);
  console.log(m ** 3);
  console.log("Hello World");
  
  m = 200;
  ```

  - 当m发生变化后

    ```js
    console.log(m);
    console.log(m * 2);
    console.log(m ** 3);
    console.log("Hello World");
    ```

    - 这一段代码就要以m的新值，重新执行一遍

### 2.对象的响应式

```js
const obj = {
  name: "why",
  age: 18,
};

console.log(obj.name);  // 想象成100行代码

console.log(obj.age);
```

- 当obj中的name发生变化时，执行那100行代码

- 当obj中的age发生变化时，执行age有关的代码

  ```js
  const obj = {
    name: "why",
    age: 18,
  };
  
  const newName = obj.name
  console.log(obj.name);
  
  obj.name = "yt";
  ```

  - 由于 obj.name = "yt"; obj中的name发生了变化
  - 那么const newName = obj.name;console.log(obj.name);这两行代码就需要重新执行一遍
  - 当然并不一定，有可能还有其他代码，但是并没有用到age，如果你希望当age发生改变时，也要重新执行一遍，也是可以的

### 3.响应式函数的封装

- 我们简化一下之前所说的

  ```js
  const obj = {
    name: "why",
    age: 18,
  };
  
  function foo() {
    const newName = obj.name;
    console.log("Hello World");
    console.log(obj.name);  
  }
  
  obj.name = "yt";
  ```

  - 当obj的name发生了变化，foo这个函数就需要被重新执行

  - 但是这里还有一个问题，假如我们还有一个函数叫bar，但是呢，这个函数并不想加入响应式，那应该怎么办？

  - 我们可以额外创建一个函数：watchFn

  - 如果你想要让foo加入响应式，就把foo这个函数传给watchFn这个函数

  - 这个时候关键的问题就来到了watchFn这个函数上了，如何去封装这个函数呢？

    ```js
    const reactiveFns = [];
    function watchFn(fn) {
      reactiveFns.push(fn);
    };
    
    const obj = {
      name: "why",
      age: 18,
    };
    
    watchFn(function() {
      const newName = obj.name;
      console.log("Hello World");
      console.log(obj.name);  
    });
    
    watchFn(function() {
      console.log(obj.name);
    });
    
    function bar() {
      console.log("普通代码");
    };
    
    obj.name = "yt";
    
    reactiveFns.forEach(item => {
      item()
    })
    ```

    - 这个时候当name发生变化时，就可以把那些加入响应式的函数进行执行了

### 4.收集依赖的类的封装

```js
class Depend {
  constructor() {
    this.reactiveFns = [];
  };

  addDepend(reactiveFn) {
    this.reactiveFns.push(reactiveFn)
  };

  notifyDepend() {
    this.reactiveFns.forEach(item => {
      item();
    });
  }
};

const d = new Depend();
function watchFn(fn) {
  d.addDepend(fn);
};

const obj = {
  name: "why",
  age: 18,
};

watchFn(function() {
  const newName = obj.name;
  console.log("Hello World");
  console.log(newName);  
});

watchFn(function() {
  console.log(obj.name);
});

obj.name = "yt";
d.notifyDepend();
```

- 这样做有什么好处呢？
- 这样做的最大好处，就是代码的复用，以后对于name的依赖收集可以用这个类，age的依赖收集也可以用这个类

### 5.自动监听对象变化

- 监听对象的属性变化：Proxy/Object.defineProperty

- 我们目前暂时先仅监听obj这一个对象的属性变化

  ```js
  const objProxy = new Proxy(obj, {
    get: function(target, key, receiver) {
      return Reflect.get(target, key, receiver);
    },
    set: function(target, key, newValue, receiver) {
      Reflect.set(target, key, newValue, receiver);
      d.notifyDepend();
    },
  });
  
  objProxy.name = "yt";
  ```

  - 这样做的好处是，假如我们修改了name好多次，就不用重复地调用d.notifyDepend()
  - 这里其实还有问题，那就是无法精准的监听
    - 比如我修改了age，其实关于name的所有监听的函数，还会再执行一遍
    - 就是我们把所有需要监听的函数放到了reactiveFns数组中

### 6.依赖收集的管理

```js
// 我们还有一个info对象
const info = {
  name: "kobe",
  address: "洛杉矶",
};

watchFn(function() {
  console.log(info.name);
});
watchFn(function() {
  console.log(info.address);
});
```

- 在我们的真实开发时，我们可能有多个对象

- 每个对象又有多个属性，每个属性都应该有属于自己的depend

  ```js
  const objMap = new Map();
  objMap.set("name", "nameDepend");
  objMap.set("age", "ageDepend");
  
  const infoMap = new Map();
  infoMap.set("name", "nameDepend");
  infoMap.set("address", "addressDepend");
  
  const weakMap = new WeakMap();
  weakMap.set(obj, objMap);
  weakMap.set(info, infoMap);
  
  const depend = weakMap.get(obj).get("name");
  depend.notifyDepend();
  ```

  - 这是伪代码，就是知道这么个过程就行

- 但是现在的问题在于

  ```js
  const objProxy = new Proxy(obj, {
    set: function(target, key, newValue, receiver) {
      Reflect.set(target, key, newValue, receiver);
      d.notifyDepend();
    },
  });
  ```

  - 这里的d.notifyDepend();是没有做出区分的

  - 我们应该获取一个真实的depend，比如name发生变化了，就要获取到name的depend

  - 我们需要封装一个获取depend的函数

    ```js
    const targetMap = new WeakMap();
    function getDepend(target, key) {
      let map = targetMap.get(target);
      if(!map) {
        map = new Map();
        targetMap.set(target, map);
      };
    
      let depend = map.get(key);
      if(!depend) {
        depend = new Depend();
        map.set(key, depend);
      };
    
      return depend;
    }
    
    const obj = {
      name: "why",
      age: 18,
    };
    
    const objProxy = new Proxy(obj, {
      get: function(target, key, receiver) {
        return Reflect.get(target, key, receiver);
      },
      set: function(target, key, newValue, receiver) {
        Reflect.set(target, key, newValue, receiver);
        const depend = getDepend(target, key);
        console.log(depend.reactiveFns);  // []
        depend.notifyDepend();
      },
    });
    ```

    - 这里的reactiveFns是空的，为什么？因为压根就没有执行depend.addDepend(fn);

