### 1.浏览器渲染过程补充

- HTML通过HTML解析器解析成DOM树，将DOM树理解为一个对象
- CSS通过CSS解析器解析成规则树
- 往DOM树上附加规则树，就是为对应的元素加一些对象，生成Render树
- 但是如果我们要把每个对象都渲染到浏览器上，还要计算每个元素在浏览器中的具体位置
- 所以layout就是做这个工作的，比如Render树记录了一个元素，这个元素有宽高，也有display: none;
- 不过这个元素是不需要显示的，所以具体的位置还需要layout进行计算和排布
- 最后经过绘制展示在浏览器上

### 2.回流（重排）和重绘

- 理解回流reflow：（也可以称之为重排）
  - 第一次确定节点的大小和位置，称之为布局（layout）
  - 之后对节点的大小、位置修改重新计算称之为回流

- 什么情况下引起回流呢？
  - DOM结构发生改变（添加新的节点或者移除节点）
  - 改变了布局（修改了width、height、padding、font-size等值）
  - 窗口resize（修改了窗口的尺寸等）
  - 调用getComputedStyle方法获取尺寸、位置信息
- 理解重绘repaint：
  - 第一次渲染内容称之为绘制（paint）
  - 之后重新渲染称之为重绘。
- 什么情况下会引起重绘呢？
  - 修改背景色、文字颜色、边框颜色、样式等

- 回流一定会引起重绘，所以回流是一件很消耗性能的事情
  - 所以在开发中要尽量避免发生回流：
    - 修改样式时尽量一次性修改
    - 尽量避免频繁的操作DOM
    - 尽量避免通过getComputedStyle获取尺寸、位置等信息
    - 对某些元素使用position的absolute或者fixed并不是不会引起回流，而是开销相对较小

### 3.分层

- 绘制元素时，可以将布局后的元素绘制到多个合成图层中
  - 这是浏览器的一种优化手段
- 默认情况下，标准流中的内容都是被绘制在同一个图层（Layer）中的
- 而一些特殊的属性，会创建一个新的合成层（CompositingLayer）
  - 新的图层可以利用GPU来加速绘制
  - 因为每个合成层都是单独渲染的
- 那么哪些属性可以形成新的合成层呢？常见的一些属性：
  - 3D transform
  - video、canvas、iframe
  - opacity 动画转换时
  - position: fixed
  - will-change：一个实验性的属性，提前告诉浏览器元素可能发生哪些变化
  - animation 或 transition 设置了opacity、transform；
- 分层确实可以提高性能，但是它以内存管理为代价
  - 因此不应作为 web 性能优化策略的一部分过度使用。

### 4.defer属性

- defer 属性告诉浏览器不要等待脚本下载，而是继续解析HTML，构建DOM Tree
  - 脚本会由浏览器来进行下载，但是不会阻塞DOM Tree的构建过程
  - 如果脚本提前下载好了，它会等待DOM Tree构建完成
  - 在DOMContentLoaded事件之前先执行defer中的代码
    - 所以DOMContentLoaded总是会等待defer中的代码先执行完成
- 多个带defer的脚本是可以保持正确的执行顺序
- defer可以提高页面的性能，并且推荐放到head元素中
- 注意：defer仅适用于外部脚本，对于script默认内容会被忽略

### 5.async属性

- async 特性与 defer 有些类似，它也能够让脚本不阻塞页面
- async 可以让一个脚本完全独立的
  - 浏览器不会因 async 脚本而阻塞（与 defer 类似）
  - async脚本不能保证顺序，它是独立下载、独立运行，不会等待其他脚本
  - async不会能保证在DOMContentLoaded之前或者之后执行
- defer通常用于需要在文档解析后操作DOM的JavaScript代码，并且对多个script文件有顺序要求
- async通常用于独立的脚本，对其他脚本，甚至DOM没有依赖