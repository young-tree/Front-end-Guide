### 1.继承

- 假如我们没有继承，我们要封装两个类：Student类和Teacher类

  ```js
  function Student(name, age, sno) {
    this.name = name;
    this.age = age;
    this.sno = sno;
  };
  
  Student.prototype.running = function() {
    console.log(this.name + "在跑步~");
  };
  
  Student.prototype.eating = function() {
    console.log(this.name + "在吃饭~");
  };
  
  Student.prototype.studying = function() {
    console.log(this.name + "在学习~");
  };
  
  function Teacher(name, age, title) {
    this.name = name;
    this.age = age;
    this.title = title;
  };
  
  Teacher.prototype.running = function() {
    console.log(this.name + "在跑步~");
  };
  
  Teacher.prototype.eating = function() {
    console.log(this.name + "在吃饭~");
  };
  
  Teacher.prototype.teaching = function() {
    console.log(this.name + "在教学~");
  };
  ```

  - 我们的代码有非常多的重复逻辑

- 继承就是将一些重复的代码抽取到一个父类里面，而子类只需要处理属于自己的特殊属性和方法即可

- 当子类继承父类后，就可以拥有父类中的属性和方法

### 2.实现继承

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
};

Person.prototype.eating = function() {
  console.log(this.name + "在吃饭~");
};

Person.prototype.running = function() {
  console.log(this.name + "在跑步~");
};

function Student(sno) {
  this.sno = sno;
};

Student.prototype = new Person("yt", 22);

Student.prototype.studying = function() {
  console.log(this.name + "在学习~");
};

var stu = new Student(1);
console.log(stu.name);
console.log(stu.age);
console.log(stu.sno);
stu.eating();
stu.running();
stu.studying();

function Teacher(title) {
  this.title = title;
};

Teacher.prototype = new Person("why", 18);

Teacher.prototype.teaching = function() {
  console.log(this.name + "在教学~");
};

var tec = new Teacher("主讲");
console.log(tec.name);
console.log(tec.age);
console.log(tec.title);
tec.eating();
tec.running();
tec.teaching();
```

- 我们改变了Student函数的显示原型指向，让它指向new出来的对象
- 假如我们去查找stu.name，首先会看一下自己new出来的对象中有没有name属性，没有就去`__proto__`中查找，由于是new出来的，所以`__proto__`指向Student.prototype，而Student.prototype指向new出来的Person对象，所以`__proto__`指向Person对象，Person对象中是有name的
- 由于Person对象是new出来的，所以它的`__proto__`属性指向Person函数的显示原型，Person函数的显示原型中有一个`__proto__`属性，这个`__proto__`属性指向Object显示原型
- 假如我们查找的是eating方法，由于new出来的Person对象中没有eating方法，就会找到Person对象的`__proto__`属性，而Person对象的`__proto__`属性指向Person函数的显示原型，Person函数的显示原型中是有eating方法的，所以可以查到，就可以使用。

![image-20220305104811486](https://s2.loli.net/2022/03/05/VOp5SJDytBbPhqT.png)

### 3.原型链实现继承的弊端

- 当我们直接打印上面stu对象，继承的属性是看不见

  ```js
  console.log(stu);  // Person { sno: 1 }
  ```

  - 它有两个问题，第一个就是：名字是Person，应该是Student才对，这个待会再说
  - 第二个是：name、age这两个继承的属性看不见

- 先获取引用，再修改引用会有影响

  ```js
  function Person() {
    this.friends = [];
  };
  
  var stu2 = new Student(2);
  var stu3 = new Student(3);
  
  console.log(stu2.friends); // []
  console.log(stu3.friends); // []
  
  stu2.friends.push("kobe");
  
  console.log(stu2.friends); // [ 'kobe' ]
  console.log(stu3.friends); // [ 'kobe' ]
  ```

  - 这里是找到父类的friends, 对父类的friends进行了更改

  - 但是直接为stu对象赋值不会产生影响

    ```js
    var stu2 = new Student(2);
    var stu3 = new Student(3);
    
    stu2.name = "hhh";
    
    console.log(stu2.name);  // hhh
    console.log(stu3.name);  // yt
    ```

    - 这里之所以不会产生影响，是因为它直接在stu2这个对象中添加了一个name属性
    - 而不是找到new出来的父类Person对象上的name属性，再进行修改

- 不好在new Student();时为它传name的值和age的值

  ```js
  var stu = new Student("yt", 18, 1);
  ```

  - 这么做，不好处理

### 4.借用构造函数方案

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.friends = [];
};

Person.prototype.eating = function() {
  console.log(this.name + "在吃饭~");
};

Person.prototype.running = function() {
  console.log(this.name + "在跑步~");
};

function Student(name, age, sno) {
  Person.call(this, name, age);
  this.sno = sno;
};

Student.prototype = new Person();

Student.prototype.studying = function() {
  console.log(this.name + "在学习~");
};

var stu = new Student("yt", 18, 1);
```

- 只需要在Student函数中写一段代码就可以解决上面的问题

  ```js
  function Student(name, age, sno) {
    Person.call(this, name, age);
    this.sno = sno;
  };
  ```

![image-20220305114922053](https://s2.loli.net/2022/03/05/wYU4bMvoRdAFytk.png)

- 为了解决原型链继承中存在的问题，开发人员提供了一种新技术：constructor stealing（借用构造函数、经典继承、伪造函数）
  - steal有偷窃剽窃之意，这里翻译成借用
- 借用构造函数继承的做法：在子构造函数中调用父构造函数
  - 由于函数可以在任意时刻被调用
  - 所以可以通过apply或者call方法在new子构造函数时执行父构造函数

### 5.借用构造函数继承面临的问题

1. 无论在什么情况下都要调用两次父构造函数
   - 第一次在给子类原型赋值时，把自身给new了
   - 第二次在创建子类实例时，在子类构造函数内部被调用
2. 所有的子类实例会拥有两份父类的属性
   - 一份是在自己的实例中
   - 另一份在父类的实例中