### 1.父类原型直接赋值给子类原型

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.friends = [];
};

Person.prototype.eating = function() {
  console.log(this.name + "在吃饭~");
};

function Student(name, age, sno) {
  Person.call(this, name, age);
  this.sno = sno;
};

Student.prototype = Person.prototype;

Student.prototype.studying = function() {
  console.log(this.name + "在学习~");
};

var stu = new Student("yt", 18, 1);
```

- 这样做的一个最大问题是studying被加入到了父类的原型当中
- 我们应该给Person实例添加一个方法，不应该添加到Person原型中
- 还有，由于我们还有Teacher类，Teache类也会有这个studying这个方法

### 2.原型式继承函数-对象

```js
var obj = {
  name: "why",
  age: 18,
};

function createObject(o) {
  var newObj = {};
  Object.setPrototypeOf(newObj, o);  // 将o作为newObj对象的隐式原型
  // newObj的隐式原型指向o对象
  return newObj;
};

var info = createObject(obj);
console.log(info);  // {}
console.log(info.__proto__);  // { name: "why", age: 18 }
```

- 道格拉斯怎么实现的呢?

  ```js
  var obj = {
    name: "why",
    age: 18,
  };
  
  function createObject(o) {
    function Fn() {}
    Fn.prototype = o;
    var newObj = new Fn();
    return newObj;
  }
  
  var info = createObject(obj);
  console.log(info);
  console.log(info.__proto__);
  ```

  - 让某个函数的显示原型等于传进来的o，然后new这个函数，所以new出来的实例中的隐式原型就指向Fn函数的显示原型，又因为Fn函数的显示原型指向o，所以新的对象的隐式原型指向o

  - 注意一定不要用下面的方式来做

    ```js
    function createObject(o) {
      var newObj = {};
      newobj.__proto__ = o;
      return newObj;
    }
    ```

    - 不能这样做的原因是 `__proto__` 存在兼容性问题

- 其实这两种都没必要用，现在有一个create方法。

  ```js
  var obj = {
    name: "why",
    age: 18
  }
  
  var newObj = Object.create(obj);
  ```

### 3.寄生式继承

```js
var personObj = {
  running() {
    console.log("running");
  },
};

function createStudent(name) {
  var stu = Object.create(personObj)
  stu.name = name;
  stu.studying = function() {
    console.log("studying~")
  }
  return stu;
}

var stuObj = createStudent("why");
var stuObj1 = createStudent("yt");
```

### 4.寄生组合式继承

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.friends = [];
};

Person.prototype.eating = function() {
  console.log(this.name + "在吃饭~");
};

function Student(name, age, sno) {
  Person.call(this, name, age);
  this.sno = sno;
};

// 创建一个新的对象，对象的隐式原型指向Person.prototype
// 然后在把这个新的对象赋值给Student.prototype
Student.prototype = Object.create(Person.prototype);

Student.prototype.studying = function() {
  console.log(this.name + "在学习~");
};

var stu = new Student("yt", 18, 1);
console.log(stu);  // Person { name: 'yt', age: 18, friends: [], sno: 1 }
```

- 这里为什么打印Person？

  - 我们首先要知道，名字是怎么拿到的：constructor.name
  - 我们会发现，我们给stu的原型赋值了一个新对象，新对象当然没有constructor
  - 那么它接着沿着原型链继续找，就找到了Person.prototype中的constructor

- 那么怎么才能让它打印Student呢？很简单给Student的原型上定义一个constructor就行了

  ```js
  Student.prototype = Object.create(Person.prototype);
  Student.prototype.constructor = Student;
  ```

  ```js
  Student.prototype = Object.create(Person.prototype);
  Object.defineProperty(Student.prototype, "constructor", {
    configurable: true,
    enumerable: false,
    writable: true,
    value: Student,
  });
  ```

  ```js
  console.log(stu);  // Student { name: 'yt', age: 18, friends: [], sno: 1 }
  ```

### 5.优化

- 假如我们还有一个Teacher类，我们需要把中间那部分代码又要写一遍

- 所以我们需要一个工具函数

  ```js
  function inheritPrototype(SubType, SuperType) {
    SubType.prototype = Object.create(SuperType.prototype);
    Object.defineProperty(SubType.prototype, "constructor", {
      configurable: true,
      enumerable: false,
      writable: true,
      value: SubType,
    });
  }
  
  function Person(name, age) {
    this.name = name;
    this.age = age;
    this.friends = [];
  };
  
  Person.prototype.eating = function() {
    console.log(this.name + "在吃饭~");
  };
  
  function Student(name, age, sno) {
    Person.call(this, name, age);
    this.sno = sno;
  };
  
  inheritPrototype(Student, Person);
  
  Student.prototype.studying = function() {
    console.log(this.name + "在学习~");
  };
  
  var stu = new Student("yt", 18, 1);
  console.log(stu);
  ```

  - 由于Object.create这个方法比较新，你也会看到这样的代码

    ```js
    function createObj(o) {
      function Fn() {};
      Fn.prototype = o;
      return new Fn;
    }
    
    function inheritPrototype(SubType, SuperType) {
      SubType.prototype = createObject(SuperType.prototype);
      Object.defineProperty(SubType.prototype, "constructor", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: SubType,
      });
    }
    ```


### 6.对象的方法补充

- create

  ```js
  var obj = {
    name: "yt",
    age: 22,
  };
  
  var info = Object.create(obj, {
    address: {
      configurable: true,
      enumerable: true,
      writable: true,
      value: "济南市",
    },
  });
  
  console.log(info);  // { address: '济南市' }
  console.log(info.__proto__);  // { name: 'yt', age: 22 }
  ```

  - 这个address其实是为info这个对象添加的
  - 并不是添加到info的隐式原型中

- 判断某个属性是不是在这个对象的本体上

  ```js
  console.log(info.hasOwnProperty("address"));  // true
  console.log(info.hasOwnProperty("name"));  // false
  ```

- in 操作符

  ```js
  console.log("address" in info);  // true
  console.log("name" in info);  // true
  ```

- for in

  ```js
  for(var key in info) {
    console.log(key)
  }
  // address
  // name
  // age
  ```

- instanceof

  ```js
  function createObj(o) {
    function Fn() {};
    Fn.prototype = o;
    return new Fn;
  }
  
  function inheritPrototype(SubType, SuperType) {
    SubType.prototype = createObject(SuperType.prototype);
    Object.defineProperty(SubType.prototype, "constructor", {
      configurable: true,
      enumerable: false,
      writable: true,
      value: Student,
    });
  }
  
  function Person() {};
  
  function Student() {};
  
  inheritPrototype(Student, Person);
  
  var stu = new Student();
  
  console.log(stu instanceof Student);  // true
  ```

  - 这里有一个继承关系
    - Student继承自Person
    - 我们通过Student创建出来一个stu对象，那么这个stu对象是不是Student类型呢？
    - stu instanceof Student：这句话会去判断Student.prototype有没有在stu的原型链上出现过

  ```js
  console.log(stu instanceof Person);  // true
  ```

  - 这个是否为true，就要看一下Person.prototype是否出现在stu的原型链上

  ```js
  console.log(stu instanceof Object);  // true
  ```

  - 当然是true，因为`Person.prototype.__proto__`指向Object的显示原型

- isPrototypeOf

  - 用于检查某个对象是否出现在某个实例对象的原型链上

  - 某个对象的隐式原型是否等于这个对象
  
    ```js
    function Person() {};
    
    var p = new Person();
    console.log(Person.prototype.isPrototypeOf(p));  // true
    ```
    
  - Person.prototype是否出现在p的原型链上
      
  - 与上一个的区别在于，上一个是直接判断函数，函数再自己拿自己的显示原型去判断
  
  - 下面这段代码你还能用instanceof去判断吗？
  
    ```js
    var obj = {
      name: "why",
      age: 18,
    };
    
    var info = Object.create(obj)
    ```
  
  - info接收一个全新的空对象，这个空对象的隐式原型指向，某个函数的显示原型，某个函数的显示原型指向obj，所以info这个全新的空对象的隐式原型指向obj，所以info继承自obj
  
    ```js
    console.log(obj.isPrototypeOf(info)); // true
    ```
  
    - 而我们实现的继承不同在于，obj这个对象是Person.prototype
  

### 7.总结一下

- `stu.__proto__`指向Student.prototype，它又指向一个工具对象，工具对象的`__proto__`指向Person.prototype，Person.prototype中的`__proto__`属性又指向Object.prototype
- 查找的位置
  - stu对象
  - `stu.__proto__`和Student.prototype其实是一个对象
  - 工具对象
  - 工具对象的`__proto__`和Person.prototype是一个对象
  - Person.prototype中的`__proto__`和Object.prototype又是同一个对象
- 你会发现查找属性或者方法的时候，在自己的对象中查不到时，总是去显示原型上查找属性或方法
- `__proto__`更像是一座座桥梁，帮助我们从上一个对象查找完再到下一个对象中进行查找
- 你还会发现，Student继承自Person，而Person继承自Object
  - 所以我们可以说Student继承自Object
  - 也可以说所有的类或者构造函数，最终都是继承自Object
- 这时候会出现一个问题，我们发现Person继承Object的实现是通过Person中的`__proto__`指向Object的显示原型对象
  - 那我们要用工具对象绕一圈的原因是，我们无法在Student中拿到`__proto__`，能拿到是因为浏览器实现了，有的不一定实现，所以会存在兼容问题。
- Person的原型对象本身就是一个对象，对象存着一些东西，这些东西中有一个`__proto__`属性
- 我们是让Student.prototype直接等于一个对象，我们往这个对象中添加一些自己的东西，然后它还有`__proto__`，它的`__proto__`自动指向自己的显示原型，而它的显示原型指向Person的显示原型，所以它的`__proto__`自动指向Person的显示原型

