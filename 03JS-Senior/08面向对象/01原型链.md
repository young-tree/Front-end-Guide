### 1.下面这段代码能这样做吗？

```js
function Person(name, age, height, address) {
  Person.prototype.name = name;
  Person.prototype.age = age;
  Person.prototype.height = height;
  Person.prototype.address = address;
};

var p1 = new Person("why", 18, 1.88, "广州市");
var p2 = new Person("yt", 1.74, 22, "济南市");
```

- 不行，因为new操作符所创建的对象中什么都没有

### 2.函数原型和构造函数结合

- 把函数放到原型上，就可以实现共用

  ```js
  function Person(name, age, height, address) {
    this.name = name;
    this.age = age;
    this.height = height;
    this.address = address;
  };
  
  Person.prototype.eating = function() {
    console.log(this.name + "在吃东西~");
  };
  
  Person.prototype.sporting = function() {
    console.log(this.name + "在运动~");
  };
  
  var p1 = new Person("why", 18, 1.88, "广州市");
  var p2 = new Person("yt", 1.74, 22, "济南市");
  
  p1.eating();  // why在吃东西
  p2.eating();  // yt在吃东西
  ```

### 3.构造函数和类

- Person这个函数学名是构造函数，因为我们new它了。
- 但是在很多面向对象的编程语言中，尤其是Java，new一个东西，一般代表着类
- 所以我们习惯称之为类，不过在早期的js中是没有类这个概念的

### 4.面向对象的特性

- 面向对象有三大特性：封装、继承、多态（也可以是四大特性，还有一个抽象）
  - 封装：在第二部分中，将属性和方法封装到一个类（构造函数）中，整个过程称之为封装
    - 编写类的过程叫做封装
  - 继承：重复利用一些代码，对代码进行复用。继承是多态的前提
  - 多态：不同的数据类型，执行相同的操作，产生不同的形态（行为）

- 继承是如何工作的？
  - 继承可以帮助我们将重复的代码和逻辑抽取到父类中，子类中只需要直接继承过来使用即可

### 5.原型链

- 但是在开始说继承之前，我们要先把原型链搞明白
- 利用原型链的机制实现继承

### 6.一段代码

```js
var obj = {
  name: "yt",
  age: 18,
  height: 1.88,
};

console.log(obj.name);
```

- 当我们取obj对象中的某个属性时，触发的是[[get]]操作

  - 在当前的对象中查找属性
  - 如果没有找到，就到隐式原型中进行查找，如果依然没有找到就打印undefined

- 上面的解释比较简单

  - 这里的隐式原型是一个对象，那么这个隐式原型是不是也应该有`__proto__`
  - 所以，在这个隐式原型上找不到name就会去这个隐式原型的隐式原型上找有没有name
  - 这样的一个一个的隐式原型形成了一个链条，一般就称之为原型链（prototype chain）

- 那我们会担心，这样一直一个一个的找，不就会无穷了吗？

  - 它会有一个顶层的原型对象，如果顶层的原型对象依然没有，就会返回undefined

- 但是这里你会发现一个问题，请看下面这段代码

  ```js
  var obj = {
    age: 18,
    height: 1.88,
  };
  
  obj.__proto__.__proto__.name = "coderwhy"
  
  console.log(obj.name);
  ```

  - 这样子做是会报错的

  - 但是按照之前的逻辑应该是可以这样的

  - 其实我猜测，他确实有这样的东西存在，那是它的内部原理，而我们不能这么模拟

    - 真实情况是`obj.__proto__`指向Object的显示原型
  - Object的显示原型中的 `__proto__` 指向null
    
  - 往null中添加一份name属性, 当然会报错
    
  - 应该这样模拟
  
    ```js
    var obj = {
      age: 18,
      height: 1.88,
    };
    
    obj.__proto__ = {};
    obj.__proto__.__proto__ = {};
  obj.__proto__.__proto__.name = "coderwhy"
    
    console.log(obj.name);  // coderwhy
    ```
  
    - 这样就会一层一层的查找下去
    - 不过我们每次都要为`__proto__`赋值一个空对象
    - 具体疑问暂时留存，后面解答
  
  ![image-20220304173142271](https://s2.loli.net/2022/03/04/71TOqxbpVIzGBMe.png)

### 7.Object原型

- 查找一个对象中没有的属性，到底到哪一层对象之后才会停止呢？

  ```js
  var obj = { name: "yt" };
  
  console.log(obj.__proto__);  // [Object: null prototype] {}
  ```

  - obj的原型：[Object: null prototype] {}
  - 而[Object: null prototype] {}其实就是最顶层的原型
  - 所以就可以解答`console.log(obj.__proto__.__proto__);`为什么为null了

- 我们知道了[Object: null prototype] {}为顶层原型，但是它是哪里来的呢？

- 首先我们要明白一件事

  ```js
  var obj1 = {};
  var obj2 = new Object();
  ```

  - 这两行代码代表一个意思

  - 那么我们还知道new操作某个函数之后所发生的五件事

    1. 在内存中创建一个对象

       ```js
       var moni = {};
       ```

    2. this的赋值

       ```js
       this = moni;
       ```

    3. 将函数的显式原型赋值给创建出来的对象的隐式原型

       ```js
       moni.__proto__ = Object.prototype;
       ```

    4. 执行代码体

    5. 返回创建的对象

  - 所以`obj2.__proto__ = Object.prototype`

  - 那么我们之前一直打印的 `obj.__proto__` 其实就是Object.prototype

  - Object.prototype就是最顶层的原型

    ```js
    var obj = {
      name: 'yt',
      age: 18,
    };
    
    console.log(obj.__proto__ === Object.prototype);  // true
    ```

### 8.顶层原型

- 系统帮我们定义好了一个函数：Object

- 那么只要是函数就有一个prototype属性，那么这个prototype属性指向Object的原型对象

- 我们之前一直说的[Object: null prototype] {}就是Object的原型对象

- 这个Object原型对象里有很多东西，只是里面的属性不可遍历

  ```js
  console.log(Object.getOwnPropertyDescriptors(Object.prototype));
  ```

  - 比如constructor，指向Object函数
  - 比如toString方法，对应一个函数对象（Function）
  - 比如valueOf，也对应一个函数对象
  - 比如`__proto__`，对应null

- 当我们创建一个字面量对象的时候

  ```js
  var obj = {
    name: "why",
    age: 18,
  };
  ```

  - 这里的obj对象中是有一个隐式原型的，这个隐式原型也指向[Object: null prototype] {}
  - 如果我们去查找address，obj中没有，就在隐式原型中查找，而隐式原型指向[Object: null prototype] {}，如果[Object: null prototype] {}也没有的话就会进入它的`__proto__`属性，我们刚才说了，顶层原型中的`__proto__`是个null，是个null就意味着不会再一层一层的往上查找了，继而返回undefined

  ![image-20220304211855269](https://s2.loli.net/2022/03/04/kzwN9hx6EpOKfab.png)

- 这时候我们再做一个之前的操作

  ```js
  var obj = {
    name: "why",
    age: 18,
  };
  
  var obj2 = {
    address: "广州市",
  };
  
  obj.__proto__ = obj2;
  console.log(obj.address);
  ```

  - 首先obj2也是一个对象，它也有`__proto__`属性，它的`__proto__`属性指向谁？
    - 也是指向顶层原型
  - 那么变化在哪呢？
    - 我们改变了obj的隐式原型的指向，我们让它指向了obj2这个对象
    - 那么我们在查找address的时候，首先会来到obj中，obj没有然后来到obj的隐式原型中，而它的隐式原型指向obj2，obj2中有，就可以拿到了。
    - 假如obj2中没有address，就会找到obj2的隐式原型，而它的隐式原型指向顶层原型，顶层原型也没有，就会找到顶层原型的`__proto__`，而顶层原型的`__proto__`是null，所以就不会再继续查找了，继而返回undefined

  ![image-20220304213345405](https://s2.loli.net/2022/03/04/kmMcIAQaU1WO9Zp.png)

- 之前那个的内存图

  ![image-20220304213515972](https://s2.loli.net/2022/03/04/FOHxNqY9nIlXREu.png)

### 9.函数中的显示原型的隐式原型

```js
function Person() {};

console.log(Person.prototype.__proto__);  // [Object: null prototype] {}
```

![image-20220304220001744](https://s2.loli.net/2022/03/04/1dRGFqpLtlQM8IX.png)

- 普通函数的prototype里也是有`__proto__`的，只是我们看不到
- 我们一般会说，Person继承自Object

