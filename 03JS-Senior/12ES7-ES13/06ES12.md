### 1.FinalizationRegistry

- 对象销毁与否

  ```js
  let obj = {name: "yt"};
  ```

  - 这里的对象是不会被销毁的，因为变量obj引用着它

  ```js
  let obj = {name: "yt"};
  obj = null;
  ```

  - 这里的对象会被销毁的

- 被注册的对象在被GC回收后，会调用FinalizationRegistry这里面的那个回调（要在浏览器中进行测试！）

  ```js
  const finalizationRegistry = new FinalizationRegistry(() => {
    console.log("对象被销毁！");
  });
  
  let obj = {name: "yt"};
  finalizationRegistry.register(obj);
  
  obj = null;
  ```

  - 你会发现这个回调，不会立马执行。
  - 虽然你给obj赋值为null了，但是GC并不会立马就去内存中将这个对象销毁掉
  - GC会不定时的去内存中进行查看，你这个对象有没有被引用着，所以这个对象会在内存中存在一段时间
  - 当我们等一会，这个回调就会执行了

- 我现在有两个注册的对象被销毁了，我应该怎么去区分呢？

  ```js
  const finalizationRegistry = new FinalizationRegistry(value => {
    console.log(value, "对象被销毁！");
  });
  
  let obj = { name: "yt" };
  let info = { name: "why" }
  finalizationRegistry.register(obj, "obj");
  finalizationRegistry.register(info, "info");
  
  obj = null;
  info = null;
  ```

  - 在注册的时候传入第二个值，代表名字
  - 在回调的时候就用形参进行接收，继而加以区分

### 2.WeakRef

```js
const finalizationRegistry = new FinalizationRegistry(a => {
  console.log(a, "对象被销毁！");
});

let obj = { name: "yt" };
let info = obj;
finalizationRegistry.register(obj, "obj");

obj = null;
```

- 像这样，一个对象被两个变量强引用着，即便obj指向null，但是info还在强引用着这个对象，所以这个对象不会被GC销毁掉

- 我可以把info对于这个对象的引用改为弱引用，比如使用WeakSet

  ```js
  const finalizationRegistry = new FinalizationRegistry(a => {
    console.log(a, "对象被销毁！");
  });
  
  let obj = { name: "yt" };
  let info = new WeakSet();
  info.add(obj);
  finalizationRegistry.register(obj, "obj");
  
  obj = null;
  ```

- 优化，使用WeakRef

  ```js
  const finalizationRegistry = new FinalizationRegistry(a => {
    console.log(a, "对象被销毁！");
  });
  
  let obj = { name: "yt" };
  let info = new WeakRef(obj);
  finalizationRegistry.register(obj, "obj");
  
  console.log(info.deref());  // { name: "yt" }
  console.log(info.deref().name);  // yt
  
  obj = null;
  ```

- 如果你这个对象被销毁了，还能拿到值吗

  ```js
  const finalizationRegistry = new FinalizationRegistry(a => {
    console.log(a, "对象被销毁！");
  });
  
  let obj = { name: "yt" };
  let info = new WeakRef(obj);
  finalizationRegistry.register(obj, "obj");
  
  obj = null;
  
  setTimeout(() => {
    console.log(info.deref()?.name);  // undefined
  }, 10000);
  ```

- deref方法

  - 原对象没有被销毁，就获取原对象
  - 如果被销毁了就为undefined

### 3.logical assignment operators

- 逻辑赋值运算

  - `||=` 逻辑或赋值运算

    ```js
    let message = "";
    
    message = message || "D";
    console.log(message);  // D
    
    message ||= "D";
    console.log(message);  // D
    ```

  - `&&=` 逻辑与赋值运算

    - 非常非常非常不推荐使用

  - `??=` 逻辑空赋值运算

    - 对逻辑或的优化
    - 这个很实用

### 4.replaceAll

- String.replaceAll方法：字符串替换

  ```js
  const message = "abcABCa";
  const newMessage = message.replaceAll("a", "d");
  
  console.log(newMessage);  // dbcABCd
  ```

  - 区分大小写

### 5.其他

- Numeric /nuˈmɛrɪk/ Separator [ˈsepəreɪtər] 数字分割符：
  - 讲过了：数字非常大的话，可以给它设置 `_` 作为分隔符

