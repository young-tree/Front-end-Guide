### 1.BigInt

- 在ES11之前，你最大可以表示一个多大的数字呢？（仅对int类型来说）

  ```js
  const maxInt = Number.MAX_SAFE_INTEGER;
  
  console.log(maxInt);  // 9007199254740991
  ```

  - MAX_SAFE_INTEGER/ˈɪntɪdʒər/：最大的安全的整数

- 那，这个数字还能再大吗

  ```js
  console.log(maxInt + 1);  // 9007199254740992
  console.log(maxInt + 2);  // 9007199254740992
  console.log(maxInt + 3);  // 9007199254740994
  console.log(maxInt + 4);  // 9007199254740996
  ```

  - 再大就会比较混乱（有可能正确也有可能不正确），变得不安全了

- 那么我们如何正确的表示一个比较大的数字呢？在ES11之后给我们提供了一个

  ```js
  const bigInt = 900719925474099400n
  console.log(bigInt);  // 900719925474099400n
  ```

- 既然可以这样表示，那能不能这样相加呢？

  ```js
  console.log(bigInt + 1);
  ```

  - 由于类型不同，这样做是会报错的。你可能要说10 + "abc"都可以成功，为什么这里就不行呢？
  - 因为像10 + "abc"或者10 + 3.14这样的做法，它内部是做了一个隐式转换的
    - 在很多语言中，是不允许一个整数和一个浮点数直接进行相加，必须把整数转为浮点数

- 那我们应该怎么运算呢

  ```js
  console.log(bigInt + 1n);  // 900719925474099401n
  ```

  - 把1也转成一个大数

- 假如我不是直接加一个数字，而是用一个变量代表一个数字，该怎么办呢？

  ```js
  const bigInt = 900719925474099400n
  const ten = 10;
  console.log(bigInt + BigInt(ten));  // 900719925474099410n
  ```

- 我们还想把一个大数转成num类型，可不可以呢？

  ```js
  const bigInt = 900719925474099400n
  console.log(bigInt);  // 900719925474099400n
  const smallNum = Number(bigInt);
  console.log(smallNum);  // 900719925474099500
  ```

  - 虽然可以转，但是不能保证是正确的

### 2.Nullish Coalescing Operator

- Coalescing/ˌkoʊəˈlesɪŋ/

- 控制合并操作、控制合并运算也就是 `??` 运算符

- 以前我们学过逻辑或运算，而且它是有弊端的

  ```js
  const foo1 = undefined;
  const foo2 = null;
  const foo3 = "";
  const foo4 = 0;
  const bar1 = foo1 || "Default Value";
  const bar2 = foo2 || "Default Value";
  const bar3 = foo3 || "Default Value";
  const bar4 = foo4 || "Default Value";
  console.log(bar1);  // Default Value
  console.log(bar2);  // Default Value
  console.log(bar3);  // Default Value
  console.log(bar4);  // Default Value
  ```

  - 针对0和空字符串，需要一些更多地操作的

- `??` 运算符就可以避免掉这些弊端

  ```js
  const foo1 = undefined;
  const foo2 = null;
  const foo3 = "";
  const foo4 = 0;
  const bar1 = foo1 ?? "Default Value";
  const bar2 = foo2 ?? "Default Value";
  const bar3 = foo3 ?? "Default Value";
  const bar4 = foo4 ?? "Default Value";
  console.log(bar1);
  console.log(bar2);
  console.log(bar3);
  console.log(bar4);
  /*
  Default Value
  Default Value
  
  0
  */ 
  ```

### 3.Optional Chaining

- 既然有对 `||` 运算符的优化，就会有对 `&&` 的优化

- 对 `&&` 的优化是要考虑它的应用场景的，一般用在某个变量有值时（这个变量一般是个对象）

- 再去这个变量中取值

  ```js
  const obj = {
    name: "yt",
    friend: {
      name: "lihua",
      works: {
        work1: "write letters",
        work2: "attend summer camp"
      }
    },
  };
  
  console.log(obj.friend.works.work1);  // write letters
  ```

  - 这样写没什么问题，但是如果obj中只有一个name属性呢？

  - 就会报错，什么错？undefined.属性，取不到，非常常见的错误，那我们可以这么做

    ```js
    const obj = {
      name: "yt",
      friend: {
        name: "lihua",
        works: {
          work1: "write letters",
          work2: "attend summer camp"
        }
      },
    };
    
    console.log(obj.friend && obj.friend.works && obj.friend.works.work1);
    // write letters
    ```

    - 虽然这样不会报错，但是你不觉得很麻烦吗

- 优化，ES11为我们提供了可选链

  ```js
  const obj = {
    name: "yt",
    friend: {
      name: "lihua",
      works: {
        work1: "write letters",
        work2: "attend summer camp"
      }
    },
  };
  
  console.log(obj.friend?.works?.work1);  // write letters
  ```

### 4.globalThis

- 在ES11之前我们要获取全局对象，是要分环境的，不同的环境，需要不同的获取方式

  - 在浏览器上可以通过this、window来获取全局对象

    ```js
    console.log(this);
    console.log(window);
    ```

  - 在nodejs中可以通过global来获取全局对象

    ```js
    console.log(global);
    ```

- 在ES11它新增了一个东西叫：globalThis

  ```js
  console.log(globalThis);
  ```

### 5.对for in进行了标准化

- 在ES11之前，很多浏览器支持通过for in的方式遍历对象，但是并没有被ECMA标准化

- 在ES11时，ECMA对其进行了标准化：for in用于遍历对象的key

  ```js
  const obj = {
    name: "yt",
    age: 22,
  };
  
  for(const key in obj) {
    console.log(key);
  };
  /*
  name
  ag
  */
  ```

### 6.其他

- dynamic import（动态导入）：ES Module模块化时再讲
- Promise.allSettled：讲Promise时再讲
- import meta：ES Module模块化时再讲

