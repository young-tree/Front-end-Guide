### 1.生成器替代迭代器

- 我们之前创建过迭代器，比如下面这段代码

  ```js
  function createArrayIterator(arr) {
    let index = 0;
    return {
      next() {
        if(index < arr.length) {
          return { done: false, value: arr[index++] }
        } else {
          return { done: true, value: undefined }
        }
      }
    }
  }
  
  const name = ["abc", "cba", "nba"];
  const iterator = createArrayIterator(name);
  ```

  - iterator就是我们创建的迭代器 [ɪ tə 'reɪ tə]

- 用生成器替代迭代器

  ```js
  function* createArrayGenerator(arr) {
    for (const item of arr) {
      yield item;
    }
  }
  
  const name = ["abc", "cba", "nba"];
  const generator = createArrayGenerator(name);
  console.log(generator.next());
  console.log(generator.next());
  console.log(generator.next());
  console.log(generator.next());
  console.log(generator.next());
  /*
  { value: 'abc', done: false }
  { value: 'cba', done: false }
  { value: 'nba', done: false }
  { value: undefined, done: true }
  { value: undefined, done: true }
  */
  ```

- yield* 语法

  - yield* 后面必须跟一个可迭代对象

    ```js
    function* createArrayGenerator(arr) {
      yield* arr
    }
    
    const name = ["abc", "cba", "nba"];
    const generator = createArrayGenerator(name);
    ```

  - yield* arr 相当于下面这段代码的语法糖

    ```js
    for (const item of arr) {
      yield item;
    }
    ```

### 2.迭代某个范围

- 我们创建一个函数，传入两个数字类型的参数，比如10和20

- 我们希望这个函数能够把10、11、12、13、14、15、16、17、18、19、20这些数字全部迭代出来

  ```js
  function createRangeIterator(start, end) {
    let index = start;
  
    return {
      next() {
        if(index <= end) {
          return { done: false, value: index++ }
        } else {
          return { done: true, value: undefined }
        }
      }
    }
  }
  
  const iterator = createRangeIterator(10, 20);
  console.log(iterator.next());
  ```

- 我们也可以用生成器实现

  ```js
  function* createRangeGenerator(start, end) {
    let index = start;
  
    while(index <= end) {
      yield index++
    }
  }
  
  const generator = createRangeGenerator(10, 20);
  ```

### 3.生成器实现自定义类的迭代

- 之前我们写过自定义类的迭代，如下面的代码

  ```js
  class Classroom {
    constructor(address, name, students) {
      this.address = address;
      this.name = name;
      this.students = students;
    };
  
    entry(student) {
      this.students.push(student);
    };
  
    [Symbol.iterator]() {
      let index = 0;
      return {
        next: () => {
          if (index < this.students.length) {
            return { done: false, value: this.students[index++] };
          } else {
            return { done: true, value: undefined }
          }
        },
        return() {
          console.log("被拦截！");
          return { done: true, value: undefined };
        },
      };
    };
  };
  
  const classroom = new Classroom("天河", "弘源", ["abc", "cba", "nba"]);
  classroom.entry("mba");
  
  for (const item of classroom) {
    console.log(item);
    if(item === "cba") break;
  };
  ```

- 我们想要改造一下它

  ```js
  class Classroom {
    constructor(address, name, students) {
      this.address = address;
      this.name = name;
      this.students = students;
    };
  
    entry(student) {
      this.students.push(student);
    };
  
    *[Symbol.iterator]() {
      yield* this.students;
    };
  };
  ```

### 4.异步代码的处理方案

- 之前我们通过promise拿异步数据，如下面代码

  ```js
  function requestData(url) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve(url);
      }, 2000);
    });
  };
  
  requestData("yt").then(res => console.log(res));
  ```

- 我现在有这么一个请求

  - 第一次请求到的结果是yt，因为我传入的就是yt

  - 第二次再进行请求，要把请求到的结果拼接上aaa后再发送请求，那么第二次拿到的结果是ytaaa

  - 第三次再进行请求，要把请求到的结果拼接上bbb后再发送请求，那么第三次拿到的结果是ytaaabbb

    ```js
    function requestData(url) {
      return new Promise((resolve) => {
        setTimeout(() => {
          resolve(url);
        }, 2000);
      });
    };
    
    requestData("yt").then(res => {
      requestData(res + "aaa").then(res => {
        requestData(res + "bbb").then(res => console.log(res));
      });
    });
    ```

  - 这段代码是回调函数里面嵌套了回调函数

  - 我们一般称这种代码为：回调地狱

- 我们把刚才的方案称之为第一种方案，现在我们写一下更好一点的方案

  ```js
  requestData("yt").then(res => {
    return requestData(res + "aaa");
  }).then(res => {
    return requestData(res + "bbb");
  }).then(res => console.log(res));
  ```

### 5.生成器方案

```js
function requestData(url) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(url);
    }, 2000);
  });
};

function* getData() {
  const res1 = yield requestData("yt")
  const res2 = yield requestData(res1 + "aaa")
  const res3 = yield requestData(res2 + "bbb");
  console.log(res3);
};

const generator = getData();
generator.next().value.then(res => {
  generator.next(res).value.then(res => {
    generator.next(res).value.then(res => generator.next(res));
  });
});
```

### 6.自动化

- 上面的代码依然存在问题，我要发送第四次请求怎么办呢？

- 答案是：自动化

  ```js
  function requestData(url) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve(url);
      }, 2000);
    });
  };
  
  function* getData() {
    const res1 = yield requestData("yt")
    const res2 = yield requestData(res1 + "aaa")
    const res3 = yield requestData(res2 + "bbb");
    console.log(res3);
  };
  
  function execGenerator(genFn) {
    const generator = genFn();
  
    function exec(res){
      const result = generator.next(res);
      if(result.done) return;
      result.value.then(res => {
        exec(res);
      })
    };
    exec();
  };
  execGenerator(getData);
  ```

### 7.第三方包实现6的自动化

- npm install co

  ```js
  function requestData(url) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve(url);
      }, 2000);
    });
  };
  
  function* getData() {
    const res1 = yield requestData("yt")
    const res2 = yield requestData(res1 + "aaa")
    const res3 = yield requestData(res2 + "bbb");
    console.log(res3);
  };
  
  const co = require("co");
  co(getData);
  ```

### 8.最终方案

```js
function requestData(url) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(url);
    }, 2000);
  });
};

async function getData() {
  const res1 = await requestData("yt")
  const res2 = await requestData(res1 + "aaa")
  const res3 = await requestData(res2 + "bbb");
  console.log(res3);
};

getData();
```

