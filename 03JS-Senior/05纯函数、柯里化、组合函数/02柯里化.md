### 1.柯里化

- 它属于函数式编程的一个非常重要的概念
- 在计算机科学中，柯里化（currying/ˈkʌriɪŋ/）又译为卡瑞化或加里化
- 把接收多个参数的函数，变成接收一个单一参数的函数（这个参数是函数的第一个参数）
- 返回接收的参数中余下的参数
- 返回结果的新函数
- 柯里化声称
  - 如果你固定某些参数，你将得到接收余下参数的一个函数

### 2.总结

```js
function foo(m, n, x, y) {
  console.log(m + n + x + y);
};
foo(10, 20, 30, 40);  // 100

function bar(m) {
  return function(n){
    return function(x) {
      return function(y) {
        console.log(m + n + x + y);
      };
    };
  };
};
bar(10)(20)(30)(40);  // 100
```

- 把foo这个函数变成bar这个函数的过程，就是柯里化的过程
- 其实一个函数传两个参数也是柯里化，只要你把一个函数拆分成多个函数的过程就是柯里化

```js
var bar2 = m => n => x => y => console.log(m + n + x + y);
bar2(10)(20)(30)(40);  // 100
```

- 简化

### 3.单一职责

- 在函数式编程中，我们希望一个函数处理的问题尽可能单一，而不是将一大堆的处理过程交给一个函数来处理

- 设计模式里面有一个原则：单一职责原则（SRP single responsibility principle）

  - 它一般会用面向对象来讲，一个类尽量完成单一的一件事情

    ```js
    class App {
      // 一般是用来启动的runApp() {};
    };
    ```

- 这里有一个问题：

  - 我们可以将传入的参数在单一的函数中处理，但是能否在处理完成后，让下一个函数再使用处理后的结果

    ```js
    function foo(x, y, z) {
      x = x + 2;
      y = y * 2;
      z = z * z;
      return x + y + z;
    };
    
    console.log(foo(10, 20, 30));
    
    function sum(x) {
      x = x + 2;
      return function(y) {
        y = y * 2;
        return function(z) {
          z = z * z;
          return x + y + z;
        };
      };
    };
    
    console.log(sum(10)(20)(30));
    ```

### 4.逻辑复用

```js
function foo(m, n) {
  return m + n;
};

// 假如在程序中，我们总是想用5来与不同的数字相加
// 会造成总是重复写5的问题
console.log(foo(5, 10));
console.log(foo(5, 70));
console.log(foo(5, 80));
console.log(foo(5, 40));
console.log(foo(5, 110));

function makeAddr(count) {
  return function(num) {
    return count + num;
  };
};

var sum = makeAddr(5);
console.log(sum(10));
console.log(sum(70));
console.log(sum(80));
console.log(sum(40));
console.log(sum(110));
```

```js
function makeAddr(count) {
  count = count * count;
  return function(num) {
    return count + num;
  };
};

var sum = makeAddr(5);
console.log(sum(10));
console.log(sum(70));
console.log(sum(80));
console.log(sum(40));
console.log(sum(110));
```

- 不是简单的复用

### 5.打印日志

```js
function log(date, type, message) {
  console.log(`[${date.getHours()}: ${date.getMinutes()}][${type}]: [${message}]`);
};

log(new Date(), "DEBUG", "查找到轮播图的bug");
log(new Date(), "DEBUG", "查询菜单的bug");
log(new Date(), "DEBUG", "查询数据的bug");
```

- 传入的new Date()和"DEBU"是重复的，没必要每次都传

```js
var log = date => type => message => {
  console.log(`[${date.getHours()}: ${date.getMinutes()}][${type}]: [${message}]`);
};

var date = log(new Date());
var debug = date("DEBUG");
debug("查找到轮播图的bug");
debug("查询菜单的bug");
debug("查询数据的bug");
var feture = date("FETURE");
feture("为轮播图增加了一些新特性");
feture("为菜单增加了一些新特性");
feture("为登录页面增加了一些新特性");
```

- 柯里化优化

### 6.柯里化函数

- 我们想创建一个函数，这个函数接收一个参数，接收的参数类型是函数类型

- 我们想让这个函数可以将接收到的函数改造成柯里化函数

- 此函数可以自动将某个函数转成柯里化函数，而不是手动
  ```js
  function foo(m, n, x, y) {
    console.log(m + n + x + y);
  };
  
  function ytCurrying(fn) {};
  
  // 本来我们是要直接调用foo这个函数
  foo(10, 20, 30, 40);
  
  // 现在我们想这么调用
  var curryFoo = ytCurrying(foo);
  curryFoo(10)(20)(30)(40);
  ```

- 如何实现这个ytCurrying函数？

  ```js
  function foo(m, n, x, y) {
    console.log(m + n + x + y);
  };
  
  function ytCurrying(fn) {
    return function curried(...args) {
      // 把args的长度和fn这个函数需要的参数个数进行比较
      // args的长度：args.length;
      // 函数需要的参数个数：fn.length;
      if(args.length >= fn.length) {
        return fn.apply(this, args);
      } else {
        return function(...args2) {
          return curried.apply(this, [...args, ...args2]);
          // 不要忘了这个return
        };
      };
    };
  };
  
  var curryFoo = ytCurrying(foo);
  curryFoo(10, 20, 30, 40);
  curryFoo(10, 20)(30)(40);
  curryFoo(10, 20)(30, 40);
  curryFoo(10)(20)(30)(40);
  ```

  